// Copyright © Björn Hellander 2024
// Licensed under the MIT License. See LICENSE.txt in the repository root for license information.

// <auto-generated/>

#nullable enable

using Microsoft.CodeAnalysis.Lightup;

namespace Microsoft.CodeAnalysis.CSharp.Lightup
{
    /// <summary>Provides lightup support for class Microsoft.CodeAnalysis.CSharp.CSharpExtensions.</summary>
    public static partial class CSharpExtensionsEx
    {
        private const string WrappedTypeName = "Microsoft.CodeAnalysis.CSharp.CSharpExtensions";

        private delegate Microsoft.CodeAnalysis.DataFlowAnalysis? AnalyzeDataFlowDelegate0(Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer);
        private delegate Microsoft.CodeAnalysis.DataFlowAnalysis? AnalyzeDataFlowDelegate1(Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.PrimaryConstructorBaseTypeSyntaxWrapper primaryConstructorBaseType);
        private delegate Microsoft.CodeAnalysis.IMethodSymbol? GetDeclaredSymbolDelegate2(Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken);
        private delegate Microsoft.CodeAnalysis.INamespaceSymbol? GetDeclaredSymbolDelegate3(Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.FileScopedNamespaceDeclarationSyntaxWrapper declarationSyntax, System.Threading.CancellationToken cancellationToken);
        private delegate Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfoDelegate4(Microsoft.CodeAnalysis.SemanticModel? semanticModel, System.Int32 position, Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.PrimaryConstructorBaseTypeSyntaxWrapper constructorInitializer);
        private delegate Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfoDelegate5(Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.PrimaryConstructorBaseTypeSyntaxWrapper constructorInitializer, System.Threading.CancellationToken cancellationToken);
        private delegate System.Boolean TryGetSpeculativeSemanticModelDelegate6(Microsoft.CodeAnalysis.SemanticModel? semanticModel, System.Int32 position, Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.PrimaryConstructorBaseTypeSyntaxWrapper constructorInitializer, out Microsoft.CodeAnalysis.SemanticModel? speculativeModel);

        private static readonly AnalyzeDataFlowDelegate0 AnalyzeDataFlowFunc0;
        private static readonly AnalyzeDataFlowDelegate1 AnalyzeDataFlowFunc1;
        private static readonly GetDeclaredSymbolDelegate2 GetDeclaredSymbolFunc2;
        private static readonly GetDeclaredSymbolDelegate3 GetDeclaredSymbolFunc3;
        private static readonly GetSpeculativeSymbolInfoDelegate4 GetSpeculativeSymbolInfoFunc4;
        private static readonly GetSymbolInfoDelegate5 GetSymbolInfoFunc5;
        private static readonly TryGetSpeculativeSemanticModelDelegate6 TryGetSpeculativeSemanticModelFunc6;

        static CSharpExtensionsEx()
        {
            var wrappedType = CSharpLightupHelper.FindType(WrappedTypeName);

            AnalyzeDataFlowFunc0 = CSharpLightupHelper.CreateStaticMethodAccessor<AnalyzeDataFlowDelegate0>(wrappedType, "AnalyzeDataFlow", "semanticModelSemanticModel", "constructorInitializerConstructorInitializerSyntax");
            AnalyzeDataFlowFunc1 = CSharpLightupHelper.CreateStaticMethodAccessor<AnalyzeDataFlowDelegate1>(wrappedType, "AnalyzeDataFlow", "semanticModelSemanticModel", "primaryConstructorBaseTypePrimaryConstructorBaseTypeSyntax");
            GetDeclaredSymbolFunc2 = CSharpLightupHelper.CreateStaticMethodAccessor<GetDeclaredSymbolDelegate2>(wrappedType, "GetDeclaredSymbol", "semanticModelSemanticModel", "declarationSyntaxCompilationUnitSyntax", "cancellationTokenCancellationToken");
            GetDeclaredSymbolFunc3 = CSharpLightupHelper.CreateStaticMethodAccessor<GetDeclaredSymbolDelegate3>(wrappedType, "GetDeclaredSymbol", "semanticModelSemanticModel", "declarationSyntaxFileScopedNamespaceDeclarationSyntax", "cancellationTokenCancellationToken");
            GetSpeculativeSymbolInfoFunc4 = CSharpLightupHelper.CreateStaticMethodAccessor<GetSpeculativeSymbolInfoDelegate4>(wrappedType, "GetSpeculativeSymbolInfo", "semanticModelSemanticModel", "positionInt32", "constructorInitializerPrimaryConstructorBaseTypeSyntax");
            GetSymbolInfoFunc5 = CSharpLightupHelper.CreateStaticMethodAccessor<GetSymbolInfoDelegate5>(wrappedType, "GetSymbolInfo", "semanticModelSemanticModel", "constructorInitializerPrimaryConstructorBaseTypeSyntax", "cancellationTokenCancellationToken");
            TryGetSpeculativeSemanticModelFunc6 = CSharpLightupHelper.CreateStaticMethodAccessor<TryGetSpeculativeSemanticModelDelegate6>(wrappedType, "TryGetSpeculativeSemanticModel", "semanticModelSemanticModel", "positionInt32", "constructorInitializerPrimaryConstructorBaseTypeSyntax", "speculativeModelSemanticModel&");
        }

        /// <summary>Method added in version 4.4.0.0.</summary>
        public static Microsoft.CodeAnalysis.DataFlowAnalysis? AnalyzeDataFlow(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer)
            => AnalyzeDataFlowFunc0(semanticModel, constructorInitializer);

        /// <summary>Method added in version 4.4.0.0.</summary>
        public static Microsoft.CodeAnalysis.DataFlowAnalysis? AnalyzeDataFlow(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.PrimaryConstructorBaseTypeSyntaxWrapper primaryConstructorBaseType)
            => AnalyzeDataFlowFunc1(semanticModel, primaryConstructorBaseType);

        /// <summary>Method added in version 3.8.0.0.</summary>
        public static Microsoft.CodeAnalysis.IMethodSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken)
            => GetDeclaredSymbolFunc2(semanticModel, declarationSyntax, cancellationToken);

        /// <summary>Method added in version 4.0.0.0.</summary>
        public static Microsoft.CodeAnalysis.INamespaceSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.FileScopedNamespaceDeclarationSyntaxWrapper declarationSyntax, System.Threading.CancellationToken cancellationToken)
            => GetDeclaredSymbolFunc3(semanticModel, declarationSyntax, cancellationToken);

        /// <summary>Method added in version 3.8.0.0.</summary>
        public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, System.Int32 position, Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.PrimaryConstructorBaseTypeSyntaxWrapper constructorInitializer)
            => GetSpeculativeSymbolInfoFunc4(semanticModel, position, constructorInitializer);

        /// <summary>Method added in version 3.8.0.0.</summary>
        public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.PrimaryConstructorBaseTypeSyntaxWrapper constructorInitializer, System.Threading.CancellationToken cancellationToken)
            => GetSymbolInfoFunc5(semanticModel, constructorInitializer, cancellationToken);

        /// <summary>Method added in version 3.8.0.0.</summary>
        public static System.Boolean TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, System.Int32 position, Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.PrimaryConstructorBaseTypeSyntaxWrapper constructorInitializer, out Microsoft.CodeAnalysis.SemanticModel? speculativeModel)
            => TryGetSpeculativeSemanticModelFunc6(semanticModel, position, constructorInitializer, out speculativeModel);
    }
}
