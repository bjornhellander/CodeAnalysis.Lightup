using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace Roslyn.CodeAnalysis.Lightup.GenerateCode;

internal class Program
{
    private const string CodeAnalysisCSharpAssemblyName = "Microsoft.CodeAnalysis.CSharp.dll";

    static void Main()
    {
        var rootFolder = GetRepositoryRoot();

        var sourcePath = Path.Combine(rootFolder, "Roslyn.CodeAnalysis.Lightup.CSharp");

        var testProjectNames = GetTestProjectNames(rootFolder);
        var testProjectName = testProjectNames.Last();
        var testProjectFolder = Path.Combine(rootFolder, testProjectName);
        var codeAnalysisAssemblyPaths = Directory.GetFiles(testProjectFolder, CodeAnalysisCSharpAssemblyName, SearchOption.AllDirectories);
        var codeAnalysisAssemblyPath = codeAnalysisAssemblyPaths.SingleOrDefault();
        if (codeAnalysisAssemblyPath == null)
        {
            throw new Exception($"Unable to find {CodeAnalysisCSharpAssemblyName} in {testProjectFolder}");
        }

        var assembly = Assembly.LoadFrom(codeAnalysisAssemblyPath);
        var types = assembly.GetTypes().Where(x => x.IsPublic).ToList();
        foreach (var type in types)
        {
            var targetNamespace = GetTargetNamespace(type);

            var result = GenerateType(type, targetNamespace);

            if (result != null)
            {
                var targetFolder = GetTargetFolder(type, sourcePath);
                if (!Directory.Exists(targetFolder))
                {
                    Directory.CreateDirectory(targetFolder);
                }
                File.WriteAllText(Path.Combine(targetFolder, result.Value.Name + ".cs"), result.Value.Source, Encoding.UTF8);
            }
        }
    }

    private static string GetRepositoryRoot()
    {
        var folder = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)!;

        while (folder != null)
        {
            if (Directory.GetFiles(folder).Any(x => x.EndsWith(".sln")))
            {
                return folder;
            }

            folder = Path.GetDirectoryName(folder);
        }

        throw new InvalidOperationException();
    }

    private static List<string> GetTestProjectNames(string rootFolder)
    {
        var folders = Directory.GetDirectories(rootFolder).Select(x => Path.GetFileName(x)).ToList();
        var testProjectFolders = folders.Where(x => x.StartsWith("Roslyn.CodeAnalysis.Lightup.Test") && !x.EndsWith(".Internal")).ToList();
        return testProjectFolders;
    }

    private static (string Name, string Source)? GenerateType(Type type, string targetNamespace)
    {
        if (type.IsEnum)
        {
            return GenerateEnum(type, targetNamespace);
        }
        else if (type.IsClass && type.Name == "RecordDeclarationSyntax")
        {
            return GeneratedClass(type, targetNamespace);
        }
        else
        {
            return null;
        }
    }

    private static (string Name, string Source) GenerateEnum(Type type, string targetNamespace)
    {
        var targetName = type.Name + "Ex";

        var sb = new StringBuilder();

        sb.AppendLine($"// <auto-generated/>");
        sb.AppendLine();
        sb.AppendLine($"#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"using {type.Namespace};");
        sb.AppendLine();
        sb.AppendLine($"namespace {targetNamespace}");
        sb.AppendLine($"{{");
        sb.AppendLine($"    public class {targetName}");
        sb.AppendLine($"    {{");
        foreach (var field in type.GetFields().Where(x => x.IsStatic && x.IsPublic))
        {
            var value = Convert.ToInt32(field.GetValue(null));
            sb.AppendLine($"        public const {type.Name} {field.Name} = ({type.Name}){value};");
        }
        sb.AppendLine($"    }}");
        sb.AppendLine($"}}");

        var source = sb.ToString();
        return (targetName, source);
    }

    private static (string Name, string Source) GeneratedClass(Type type, string targetNamespace)
    {
        var targetName = type.Name + "Wrapper";
        var instanceProperties = GetInstanceProperties(type);
        var instanceMethods = GetInstanceMethods(type);

        var baseTypeName = type.BaseType!.Name;

        var sb = new StringBuilder();

        sb.AppendLine($"// <auto-generated/>");
        sb.AppendLine();
        sb.AppendLine($"#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"using Microsoft.CodeAnalysis;");
        sb.AppendLine($"using Microsoft.CodeAnalysis.CSharp;");
        sb.AppendLine($"using Microsoft.CodeAnalysis.CSharp.Syntax;");
        sb.AppendLine($"using System;");
        sb.AppendLine();
        sb.AppendLine($"namespace {targetNamespace}");
        sb.AppendLine($"{{");
        sb.AppendLine($"    public readonly struct {targetName}");
        sb.AppendLine($"    {{");
        sb.AppendLine($"        private const string WrappedTypeName = \"{type.FullName}\";");
        sb.AppendLine();
        sb.AppendLine($"        private static readonly Type? WrappedType;");
        foreach (var property in instanceProperties)
        {
            var funcDeclText = GetPropertyFuncDeclText(property, baseTypeName);
            sb.AppendLine($"        private static readonly {funcDeclText} {property.Name}Func;");
        }
        foreach (var method in instanceMethods)
        {
            var index = instanceMethods.IndexOf(method);
            var funcDeclText = GetMethodFuncDeclText(method, baseTypeName);
            sb.AppendLine($"        private static readonly {funcDeclText} {method.Name}Func{index};");
        }
        sb.AppendLine();
        sb.AppendLine($"        private readonly {baseTypeName}? WrappedObject;");
        sb.AppendLine();
        sb.AppendLine($"        static {targetName}()");
        sb.AppendLine($"        {{");
        sb.AppendLine($"            WrappedType = WrapperHelper.FindSyntaxType(WrappedTypeName);");
        foreach (var property in instanceProperties)
        {
            sb.AppendLine($"            {property.Name}Func = WrapperHelper.CreateGetAccessor<{baseTypeName}?, {GetTypeDeclText(property)}>(WrappedType, nameof({property.Name}));");
        }
        foreach (var method in instanceMethods)
        {
            var index = instanceMethods.IndexOf(method);
            var createMethod = method.ReturnType != typeof(void) ? "CreateMethodAccessor" : "CreateVoidMethodAccessor";
            sb.AppendLine($"            {method.Name}Func{index} = WrapperHelper.{createMethod}<{targetName}, {baseTypeName}?, {GetParametersTypeDeclText(method.GetParameters())}{(method.ReturnType != typeof(void) ? $", {targetName}" : "")}>(WrappedType, nameof({method.Name}));");
        }
        sb.AppendLine($"        }}");
        sb.AppendLine();
        sb.AppendLine($"        private {targetName}({baseTypeName}? obj)");
        sb.AppendLine($"        {{");
        sb.AppendLine($"            WrappedObject = obj;");
        sb.AppendLine($"        }}");
        foreach (var property in instanceProperties)
        {
            sb.AppendLine();
            sb.AppendLine($"        public readonly {GetTypeDeclText(property)} {property.Name}");
            sb.AppendLine($"            => {property.Name}Func(WrappedObject);");
        }
        sb.AppendLine();
        sb.AppendLine($"        public static implicit operator {baseTypeName}?({targetName} obj)");
        sb.AppendLine($"            => obj.Unwrap();");
        sb.AppendLine();
        sb.AppendLine($"        public static bool Is(object? obj)");
        sb.AppendLine($"            => WrapperHelper.Is(obj, WrappedType);");
        sb.AppendLine();
        sb.AppendLine($"        public static {targetName} As(object? obj)");
        sb.AppendLine($"        {{");
        sb.AppendLine($"            var obj2 = WrapperHelper.As<{baseTypeName}>(obj, WrappedType);");
        sb.AppendLine($"            return new {targetName}(obj2);");
        sb.AppendLine($"        }}");
        sb.AppendLine();
        sb.AppendLine($"        public {baseTypeName}? Unwrap()");
        sb.AppendLine($"            => WrappedObject;");
        foreach (var method in instanceMethods)
        {
            var index = instanceMethods.IndexOf(method);
            sb.AppendLine();
            sb.AppendLine($"        public readonly {(method.ReturnType != typeof(void) ? GetTypeDeclText(method.ReturnType, isNew: true) : "void")} {method.Name}({GetParametersDeclText(method.GetParameters())})");
            sb.AppendLine($"            => {method.Name}Func{index}(WrappedObject, {string.Join(", ", method.GetParameters().Select(x => x.Name))});");
        }
        sb.AppendLine($"    }}");
        sb.AppendLine($"}}");

        var source = sb.ToString();
        return (targetName, source);
    }

    private static List<PropertyInfo> GetInstanceProperties(Type type)
    {
        // Handle static properties?
        var result = type
            .GetMembers(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
            .OfType<PropertyInfo>()
            .OrderBy(x => x.Name)
            .ToList();
        return result;
    }

    private static List<MethodInfo> GetInstanceMethods(Type type)
    {
        // TODO: Handle generic methods
        // TODO: Handle static methods?
        var result = type
            .GetMembers(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
            .OfType<MethodInfo>()
            .Where(x => !x.Attributes.HasFlag(MethodAttributes.SpecialName))
            .Where(x => !x.IsGenericMethod)
            .OrderBy(x => x.Name).ThenBy(x => x.GetParameters().Length)
            .ToList();
        return result;
    }

    private static string GetPropertyFuncDeclText(PropertyInfo property, string baseTypeName)
    {
        var nullabilityInfo = new NullabilityInfoContext().Create(property);

        var sb = new StringBuilder();

        sb.Append($"Func<{baseTypeName}?, ");
        AppendTypeDeclText(sb, property.PropertyType);
        sb.Append(nullabilityInfo.ReadState != NullabilityState.NotNull ? "?" : "");
        sb.Append('>');

        var result = sb.ToString();
        return result;
    }

    private static string GetMethodFuncDeclText(MethodInfo method, string baseTypeName)
    {
        var nullabilityInfoContext = new NullabilityInfoContext();

        var sb = new StringBuilder();

        sb.Append(method.ReturnType != typeof(void) ? "Func" : "Action");
        sb.Append($"<{baseTypeName}?");

        foreach (var parameter in method.GetParameters())
        {
            sb.Append(", ");
            AppendTypeDeclText(sb, parameter.ParameterType);
            var nullabilityInfo = nullabilityInfoContext.Create(parameter);
            sb.Append(nullabilityInfo.WriteState != NullabilityState.NotNull ? "?" : "");
        }

        if (method.ReturnType != typeof(void))
        {
            sb.Append(", ");
            AppendTypeDeclText(sb, method.ReturnType, isNew: true);
        }

        sb.Append('>');

        var result = sb.ToString();
        return result;
    }

    private static string GetParametersTypeDeclText(IEnumerable<ParameterInfo> parameters)
    {
        var nullabilityInfoContext = new NullabilityInfoContext();

        var sb = new StringBuilder();
        foreach (var parameter in parameters)
        {
            if (sb.Length > 0)
            {
                sb.Append(", ");
            }

            AppendTypeDeclText(sb, parameter.ParameterType);
            var nullabilityInfo = nullabilityInfoContext.Create(parameter);
            sb.Append(nullabilityInfo.WriteState != NullabilityState.NotNull ? "?" : "");
        }

        var result = sb.ToString();
        return result;
    }

    private static string GetParametersDeclText(IEnumerable<ParameterInfo> parameters)
    {
        var nullabilityInfoContext = new NullabilityInfoContext();

        var sb = new StringBuilder();
        foreach (var parameter in parameters)
        {
            if (sb.Length > 0)
            {
                sb.Append(", ");
            }

            AppendTypeDeclText(sb, parameter.ParameterType);
            var nullabilityInfo = nullabilityInfoContext.Create(parameter);
            sb.Append(nullabilityInfo.WriteState != NullabilityState.NotNull ? "?" : "");
            sb.Append(' ');
            sb.Append(parameter.Name);
        }

        var result = sb.ToString();
        return result;
    }

    private static string GetTypeDeclText(PropertyInfo property)
    {
        var nullabilityInfo = new NullabilityInfoContext().Create(property);

        var sb = new StringBuilder();
        AppendTypeDeclText(sb, property.PropertyType);
        sb.Append(nullabilityInfo.ReadState != NullabilityState.NotNull ? "?" : "");
        var result = sb.ToString();
        return result;
    }

    private static string GetTypeDeclText(Type type, bool isNew = false)
    {
        var sb = new StringBuilder();
        AppendTypeDeclText(sb, type, isNew);
        var result = sb.ToString();
        return result;
    }

    private static void AppendTypeDeclText(StringBuilder sb, Type type, bool isNew = false)
    {
        if (type.IsGenericType)
        {
            var typeName = type.Name.Substring(0, type.Name.IndexOf('`'));
            sb.Append($"{typeName}<");
            for (var i = 0; i < type.GenericTypeArguments.Length; i++)
            {
                if (i > 0)
                {
                    sb.Append(", ");
                }
                AppendTypeDeclText(sb, type.GenericTypeArguments[i]);
            }
            sb.Append('>');
        }
        else
        {
            sb.Append($"{type.Name}{(isNew ? "Wrapper" : "")}");
        }
    }

    private static string GetTargetNamespace(Type type)
    {
        var sourceNamespace = type.Namespace!;
        var targetNamespace = sourceNamespace.Replace("Microsoft.CodeAnalysis.CSharp", "Roslyn.CodeAnalysis.Lightup.CSharp");
        return targetNamespace;
    }

    private static string GetTargetFolder(Type type, string targetProjectPath)
    {
        var sourceNamespace = type.Namespace!;
        var targetFolder = sourceNamespace.Replace("Microsoft.CodeAnalysis.CSharp", "").TrimStart('.').Replace('.', Path.DirectorySeparatorChar);
        return Path.Combine(targetProjectPath, targetFolder);
    }
}
