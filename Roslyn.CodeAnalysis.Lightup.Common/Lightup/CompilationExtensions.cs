// Copyright © Björn Hellander 2024
// Licensed under the MIT License. See LICENSE.txt in the repository root for license information.

// <auto-generated/>

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Reflection;
using System.Reflection.Metadata;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.CodeAnalysis.Lightup;
using Microsoft.CodeAnalysis.Operations.Lightup;
using Microsoft.CodeAnalysis.Text;

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for class Microsoft.CodeAnalysis.Compilation.</summary>
    public static class CompilationExtensions
    {
        private const string WrappedTypeName = "Microsoft.CodeAnalysis.Compilation";

        private delegate INamedTypeSymbol CreateAnonymousTypeSymbolDelegate0(Compilation? _obj, ImmutableArray<ITypeSymbol> memberTypes, ImmutableArray<String> memberNames, ImmutableArray<Boolean> memberIsReadOnly, ImmutableArray<Location> memberLocations, ImmutableArray<NullableAnnotationEx> memberNullableAnnotations);
        private delegate IArrayTypeSymbol CreateArrayTypeSymbolDelegate1(Compilation? _obj, ITypeSymbol elementType, Int32 rank, NullableAnnotationEx elementNullableAnnotation);
        private delegate IMethodSymbol CreateBuiltinOperatorDelegate2(Compilation? _obj, String name, ITypeSymbol returnType, ITypeSymbol operandType);
        private delegate IMethodSymbol CreateBuiltinOperatorDelegate3(Compilation? _obj, String name, ITypeSymbol returnType, ITypeSymbol leftType, ITypeSymbol rightType);
        private delegate IFunctionPointerTypeSymbolWrapper CreateFunctionPointerTypeSymbolDelegate4(Compilation? _obj, ITypeSymbol returnType, RefKind returnRefKind, ImmutableArray<ITypeSymbol> parameterTypes, ImmutableArray<RefKind> parameterRefKinds, SignatureCallingConvention callingConvention, ImmutableArray<INamedTypeSymbol> callingConventionTypes);
        private delegate INamedTypeSymbol CreateNativeIntegerTypeSymbolDelegate5(Compilation? _obj, Boolean signed);
        private delegate INamedTypeSymbol CreateTupleTypeSymbolDelegate6(Compilation? _obj, ImmutableArray<ITypeSymbol> elementTypes, ImmutableArray<String> elementNames, ImmutableArray<Location> elementLocations, ImmutableArray<NullableAnnotationEx> elementNullableAnnotations);
        private delegate INamedTypeSymbol CreateTupleTypeSymbolDelegate7(Compilation? _obj, INamedTypeSymbol underlyingType, ImmutableArray<String> elementNames, ImmutableArray<Location> elementLocations, ImmutableArray<NullableAnnotationEx> elementNullableAnnotations);
        private delegate EmitDifferenceResult EmitDifferenceDelegate8(Compilation? _obj, EmitBaseline baseline, IEnumerable<SemanticEdit> edits, Func<ISymbol, Boolean> isAddedSymbol, Stream metadataStream, Stream ilStream, Stream pdbStream, CancellationToken cancellationToken);
        private delegate ImmutableArray<INamedTypeSymbol> GetTypesByMetadataNameDelegate9(Compilation? _obj, String fullyQualifiedMetadataName);
        private delegate ImmutableArray<MetadataReference> GetUsedAssemblyReferencesDelegate10(Compilation? _obj, CancellationToken cancellationToken);
        private delegate Boolean SupportsRuntimeCapabilityDelegate11(Compilation? _obj, RuntimeCapabilityEx capability);

        private static readonly CreateAnonymousTypeSymbolDelegate0 CreateAnonymousTypeSymbolFunc0;
        private static readonly CreateArrayTypeSymbolDelegate1 CreateArrayTypeSymbolFunc1;
        private static readonly CreateBuiltinOperatorDelegate2 CreateBuiltinOperatorFunc2;
        private static readonly CreateBuiltinOperatorDelegate3 CreateBuiltinOperatorFunc3;
        private static readonly CreateFunctionPointerTypeSymbolDelegate4 CreateFunctionPointerTypeSymbolFunc4;
        private static readonly CreateNativeIntegerTypeSymbolDelegate5 CreateNativeIntegerTypeSymbolFunc5;
        private static readonly CreateTupleTypeSymbolDelegate6 CreateTupleTypeSymbolFunc6;
        private static readonly CreateTupleTypeSymbolDelegate7 CreateTupleTypeSymbolFunc7;
        private static readonly EmitDifferenceDelegate8 EmitDifferenceFunc8;
        private static readonly GetTypesByMetadataNameDelegate9 GetTypesByMetadataNameFunc9;
        private static readonly GetUsedAssemblyReferencesDelegate10 GetUsedAssemblyReferencesFunc10;
        private static readonly SupportsRuntimeCapabilityDelegate11 SupportsRuntimeCapabilityFunc11;

        static CompilationExtensions()
        {
            var wrappedType = LightupHelper.FindType(WrappedTypeName);

            CreateAnonymousTypeSymbolFunc0 = LightupHelper.CreateInstanceMethodAccessor<CreateAnonymousTypeSymbolDelegate0>(wrappedType, "CreateAnonymousTypeSymbol", "ImmutableArray`1", "ImmutableArray`1", "ImmutableArray`1", "ImmutableArray`1", "ImmutableArray`1");
            CreateArrayTypeSymbolFunc1 = LightupHelper.CreateInstanceMethodAccessor<CreateArrayTypeSymbolDelegate1>(wrappedType, "CreateArrayTypeSymbol", "ITypeSymbol", "Int32", "NullableAnnotation");
            CreateBuiltinOperatorFunc2 = LightupHelper.CreateInstanceMethodAccessor<CreateBuiltinOperatorDelegate2>(wrappedType, "CreateBuiltinOperator", "String", "ITypeSymbol", "ITypeSymbol");
            CreateBuiltinOperatorFunc3 = LightupHelper.CreateInstanceMethodAccessor<CreateBuiltinOperatorDelegate3>(wrappedType, "CreateBuiltinOperator", "String", "ITypeSymbol", "ITypeSymbol", "ITypeSymbol");
            CreateFunctionPointerTypeSymbolFunc4 = LightupHelper.CreateInstanceMethodAccessor<CreateFunctionPointerTypeSymbolDelegate4>(wrappedType, "CreateFunctionPointerTypeSymbol", "ITypeSymbol", "RefKind", "ImmutableArray`1", "ImmutableArray`1", "SignatureCallingConvention", "ImmutableArray`1");
            CreateNativeIntegerTypeSymbolFunc5 = LightupHelper.CreateInstanceMethodAccessor<CreateNativeIntegerTypeSymbolDelegate5>(wrappedType, "CreateNativeIntegerTypeSymbol", "Boolean");
            CreateTupleTypeSymbolFunc6 = LightupHelper.CreateInstanceMethodAccessor<CreateTupleTypeSymbolDelegate6>(wrappedType, "CreateTupleTypeSymbol", "ImmutableArray`1", "ImmutableArray`1", "ImmutableArray`1", "ImmutableArray`1");
            CreateTupleTypeSymbolFunc7 = LightupHelper.CreateInstanceMethodAccessor<CreateTupleTypeSymbolDelegate7>(wrappedType, "CreateTupleTypeSymbol", "INamedTypeSymbol", "ImmutableArray`1", "ImmutableArray`1", "ImmutableArray`1");
            EmitDifferenceFunc8 = LightupHelper.CreateInstanceMethodAccessor<EmitDifferenceDelegate8>(wrappedType, "EmitDifference", "EmitBaseline", "IEnumerable`1", "Func`2", "Stream", "Stream", "Stream", "CancellationToken");
            GetTypesByMetadataNameFunc9 = LightupHelper.CreateInstanceMethodAccessor<GetTypesByMetadataNameDelegate9>(wrappedType, "GetTypesByMetadataName", "String");
            GetUsedAssemblyReferencesFunc10 = LightupHelper.CreateInstanceMethodAccessor<GetUsedAssemblyReferencesDelegate10>(wrappedType, "GetUsedAssemblyReferences", "CancellationToken");
            SupportsRuntimeCapabilityFunc11 = LightupHelper.CreateInstanceMethodAccessor<SupportsRuntimeCapabilityDelegate11>(wrappedType, "SupportsRuntimeCapability", "RuntimeCapability");
        }

        /// <summary>Method added in version 3.8.0.0.</summary>
        public static INamedTypeSymbol CreateAnonymousTypeSymbol(this Compilation _obj, ImmutableArray<ITypeSymbol> memberTypes, ImmutableArray<String> memberNames, ImmutableArray<Boolean> memberIsReadOnly, ImmutableArray<Location> memberLocations, ImmutableArray<NullableAnnotationEx> memberNullableAnnotations)
            => CreateAnonymousTypeSymbolFunc0(_obj, memberTypes, memberNames, memberIsReadOnly, memberLocations, memberNullableAnnotations);

        /// <summary>Method added in version 3.8.0.0.</summary>
        public static IArrayTypeSymbol CreateArrayTypeSymbol(this Compilation _obj, ITypeSymbol elementType, Int32 rank, NullableAnnotationEx elementNullableAnnotation)
            => CreateArrayTypeSymbolFunc1(_obj, elementType, rank, elementNullableAnnotation);

        /// <summary>Method added in version 4.4.0.0.</summary>
        public static IMethodSymbol CreateBuiltinOperator(this Compilation _obj, String name, ITypeSymbol returnType, ITypeSymbol operandType)
            => CreateBuiltinOperatorFunc2(_obj, name, returnType, operandType);

        /// <summary>Method added in version 4.4.0.0.</summary>
        public static IMethodSymbol CreateBuiltinOperator(this Compilation _obj, String name, ITypeSymbol returnType, ITypeSymbol leftType, ITypeSymbol rightType)
            => CreateBuiltinOperatorFunc3(_obj, name, returnType, leftType, rightType);

        /// <summary>Method added in version 3.8.0.0.</summary>
        public static IFunctionPointerTypeSymbolWrapper CreateFunctionPointerTypeSymbol(this Compilation _obj, ITypeSymbol returnType, RefKind returnRefKind, ImmutableArray<ITypeSymbol> parameterTypes, ImmutableArray<RefKind> parameterRefKinds, SignatureCallingConvention callingConvention, ImmutableArray<INamedTypeSymbol> callingConventionTypes)
            => CreateFunctionPointerTypeSymbolFunc4(_obj, returnType, returnRefKind, parameterTypes, parameterRefKinds, callingConvention, callingConventionTypes);

        /// <summary>Method added in version 3.8.0.0.</summary>
        public static INamedTypeSymbol CreateNativeIntegerTypeSymbol(this Compilation _obj, Boolean signed)
            => CreateNativeIntegerTypeSymbolFunc5(_obj, signed);

        /// <summary>Method added in version 3.8.0.0.</summary>
        public static INamedTypeSymbol CreateTupleTypeSymbol(this Compilation _obj, ImmutableArray<ITypeSymbol> elementTypes, ImmutableArray<String> elementNames, ImmutableArray<Location> elementLocations, ImmutableArray<NullableAnnotationEx> elementNullableAnnotations)
            => CreateTupleTypeSymbolFunc6(_obj, elementTypes, elementNames, elementLocations, elementNullableAnnotations);

        /// <summary>Method added in version 3.8.0.0.</summary>
        public static INamedTypeSymbol CreateTupleTypeSymbol(this Compilation _obj, INamedTypeSymbol underlyingType, ImmutableArray<String> elementNames, ImmutableArray<Location> elementLocations, ImmutableArray<NullableAnnotationEx> elementNullableAnnotations)
            => CreateTupleTypeSymbolFunc7(_obj, underlyingType, elementNames, elementLocations, elementNullableAnnotations);

        /// <summary>Method added in version 4.0.0.0.</summary>
        public static EmitDifferenceResult EmitDifference(this Compilation _obj, EmitBaseline baseline, IEnumerable<SemanticEdit> edits, Func<ISymbol, Boolean> isAddedSymbol, Stream metadataStream, Stream ilStream, Stream pdbStream, CancellationToken cancellationToken)
            => EmitDifferenceFunc8(_obj, baseline, edits, isAddedSymbol, metadataStream, ilStream, pdbStream, cancellationToken);

        /// <summary>Method added in version 4.4.0.0.</summary>
        public static ImmutableArray<INamedTypeSymbol> GetTypesByMetadataName(this Compilation _obj, String fullyQualifiedMetadataName)
            => GetTypesByMetadataNameFunc9(_obj, fullyQualifiedMetadataName);

        /// <summary>Method added in version 4.0.0.0.</summary>
        public static ImmutableArray<MetadataReference> GetUsedAssemblyReferences(this Compilation _obj, CancellationToken cancellationToken)
            => GetUsedAssemblyReferencesFunc10(_obj, cancellationToken);

        /// <summary>Method added in version 4.8.0.0.</summary>
        public static Boolean SupportsRuntimeCapability(this Compilation _obj, RuntimeCapabilityEx capability)
            => SupportsRuntimeCapabilityFunc11(_obj, capability);
    }
}
