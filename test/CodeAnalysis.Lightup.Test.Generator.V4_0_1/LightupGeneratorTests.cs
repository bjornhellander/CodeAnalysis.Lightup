// Copyright © Björn Hellander 2024
// Licensed under the MIT License. See LICENSE.txt in the repository root for license information.

namespace CodeAnalysis.Lightup.Test.Generator.V4_0_1;

using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CodeAnalysis.Lightup.Definitions;
using CodeAnalysis.Lightup.Generator;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Testing;
using Microsoft.CodeAnalysis.Testing;
using Microsoft.CodeAnalysis.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;

[TestClass]
public class LightupGeneratorTests
{
    private const string SeparatedSyntaxListWrapperSource = @"
// <auto-generated/>
#pragma warning disable CS1591
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    public struct SeparatedSyntaxListWrapper<TNode>
    {
        private static readonly global::System.Type? WrappedType;

        private delegate int CountDelegate(object obj);
        private delegate SeparatedSyntaxListWrapper<TNode> AddRangeDelegate(object obj, global::System.Collections.Generic.IEnumerable<TNode> arg1);

        private static readonly CountDelegate CountAccessor;
        private static readonly AddRangeDelegate AddRangeAccessor;

        private readonly object wrappedObject;

        static SeparatedSyntaxListWrapper()
        {
            var wrapperNodeType = typeof(TNode);
            var wrappedNodeTypeField = wrapperNodeType.GetField(""WrappedType"", global::System.Reflection.BindingFlags.Static | global::System.Reflection.BindingFlags.NonPublic);
            var wrappedNodeType = (global::System.Type)wrappedNodeTypeField.GetValue(null);
            WrappedType = wrappedNodeType != null ? typeof(SeparatedSyntaxList<>).MakeGenericType(wrappedNodeType) : null;

            CountAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<CountDelegate>(WrappedType, nameof(Count));
            AddRangeAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<AddRangeDelegate>(WrappedType, nameof(AddRange), ""nodesIEnumerable`1"");
        }

        private SeparatedSyntaxListWrapper(object obj)
        {
            wrappedObject = obj;
        }

        public int Count
        {
            get { return CountAccessor(wrappedObject); }
        }

        public int SeparatorCount
        {
            get { throw new global::System.NotImplementedException(); }
        }

        public global::Microsoft.CodeAnalysis.Text.TextSpan FullSpan
        {
             get { throw new global::System.NotImplementedException(); }
        }

        public global::Microsoft.CodeAnalysis.Text.TextSpan Span
        {
             get { throw new global::System.NotImplementedException(); }
        }

        public TNode this[int index]
        {
             get { throw new global::System.NotImplementedException(); }
        }

        public static implicit operator SeparatedSyntaxListWrapper<SyntaxNode>(SeparatedSyntaxListWrapper<TNode> nodes)
        {
             throw new global::System.NotImplementedException();
        }

        public static implicit operator SeparatedSyntaxListWrapper<TNode>(SeparatedSyntaxListWrapper<SyntaxNode> nodes)
        {
             throw new global::System.NotImplementedException();
        }

        public static bool Is(object? obj)
        {
            return global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.Is(obj, WrappedType);
        }

        public static SeparatedSyntaxListWrapper<TNode> Wrap(object obj)
        {
            var obj2 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.Wrap<object>(obj, WrappedType);
            return new SeparatedSyntaxListWrapper<TNode>(obj2);
        }

        public object Unwrap()
        {
             return wrappedObject;
        }

        public global::Microsoft.CodeAnalysis.SyntaxToken GetSeparator(int index)
        {
             throw new global::System.NotImplementedException();
        }

        public global::System.Collections.Generic.IEnumerable<global::Microsoft.CodeAnalysis.SyntaxToken> GetSeparators()
        {
             throw new global::System.NotImplementedException();
        }

        public override string ToString()
        {
             throw new global::System.NotImplementedException();
        }

        public string ToFullString()
        {
             throw new global::System.NotImplementedException();
        }

        public TNode First()
        {
             throw new global::System.NotImplementedException();
        }

        public TNode FirstOrDefault()
        {
            throw new global::System.NotImplementedException();
        }

        public TNode Last()
        {
             throw new global::System.NotImplementedException();
        }

        public TNode LastOrDefault()
        {
             throw new global::System.NotImplementedException();
        }

        public bool Contains(TNode node)
        {
             throw new global::System.NotImplementedException();
        }

        public int IndexOf(TNode node)
        {
             throw new global::System.NotImplementedException();
        }

        public int IndexOf(global::System.Func<TNode, bool> predicate)
        {
             throw new global::System.NotImplementedException();
        }

        public int LastIndexOf(TNode node)
        {
             throw new global::System.NotImplementedException();
        }

        public int LastIndexOf(global::System.Func<TNode, bool> predicate)
        {
             throw new global::System.NotImplementedException();
        }

        public bool Any()
        {
             throw new global::System.NotImplementedException();
        }

        public SyntaxNodeOrTokenList GetWithSeparators()
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> Add(TNode node)
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> AddRange(global::System.Collections.Generic.IEnumerable<TNode> nodes)
        {
             return AddRangeAccessor(wrappedObject, nodes);
        }

        public SeparatedSyntaxListWrapper<TNode> Insert(int index, TNode node)
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> InsertRange(int index, global::System.Collections.Generic.IEnumerable<TNode> nodes)
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> RemoveAt(int index)
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> Remove(TNode node)
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> Replace(TNode nodeInList, TNode newNode)
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> ReplaceRange(TNode nodeInList, global::System.Collections.Generic.IEnumerable<TNode> newNodes)
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> ReplaceSeparator(global::Microsoft.CodeAnalysis.SyntaxToken separatorToken, global::Microsoft.CodeAnalysis.SyntaxToken newSeparator)
        {
             throw new global::System.NotImplementedException();
        }
    }
}
";

    private static readonly Dictionary<AssemblyKind, string> AssemblyKindStrings = new()
    {
        [AssemblyKind.Common] = "Microsoft.CodeAnalysis.Common",
        [AssemblyKind.CSharp] = "Microsoft.CodeAnalysis.CSharp",
        [AssemblyKind.WorkspacesCommon] = "Microsoft.CodeAnalysis.Workspaces.Common",
        [AssemblyKind.CSharpWorkspaces] = "Microsoft.CodeAnalysis.CSharp.Workspaces",
    };

    private static readonly Dictionary<AssemblyKind, string> ExampleTypeNames = new()
    {
        [AssemblyKind.Common] = "Microsoft.CodeAnalysis.IOperation",
        [AssemblyKind.CSharp] = "Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax",
        [AssemblyKind.WorkspacesCommon] = "Microsoft.CodeAnalysis.WorkspaceChangeKind",
    };

    protected virtual bool SupportsFoldersInFilePaths => false;

    [TestMethod]
    public async Task TestNoAssemblyKindInConfigurationFile()
    {
        var test = CreateTest(null, "3.3.0.0", [""], shouldGeneratedFiles: false);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestNoBaselineVersionInConfigurationFile()
    {
        var test = CreateTest(AssemblyKind.Common, null, [""], shouldGeneratedFiles: false);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestUnsupportedFoldersInFilePaths()
    {
        if (SupportsFoldersInFilePaths)
        {
            return;
        }

        var test = CreateTest(AssemblyKind.Common, "3.3.0.0", [""], useFoldersInFilePaths: true, shouldGeneratedFiles: false);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestSeparatedSyntaxListWrapper()
    {
        var source = SeparatedSyntaxListWrapperSource;

        var test = CreateTest(AssemblyKind.CSharp, "3.0.0.0", [""]);
        var generatedFilePath = "SeparatedSyntaxListWrapper.g.cs";
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestCommonConversion_V3_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for struct Microsoft.CodeAnalysis.Operations.CommonConversion.</summary>
    public static partial class CommonConversionEx
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.Operations.CommonConversion"";

        private delegate global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToTypeGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj);
        private delegate global::System.Boolean IsNullableGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj);

        private static readonly ConstrainedToTypeGetterDelegate ConstrainedToTypeGetterFunc;
        private static readonly IsNullableGetterDelegate IsNullableGetterFunc;

        static CommonConversionEx()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            ConstrainedToTypeGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<ConstrainedToTypeGetterDelegate>(wrappedType, nameof(ConstrainedToType));
            IsNullableGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<IsNullableGetterDelegate>(wrappedType, nameof(IsNullable));
        }

        /// <summary>Property added in version 4.3.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToType(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
        {
            return ConstrainedToTypeGetterFunc(_obj);
        }

        /// <summary>Property added in version 3.7.0.0.</summary>
        public static global::System.Boolean IsNullable(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
        {
            return IsNullableGetterFunc(_obj);
        }
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.3.0.0", ["Microsoft.CodeAnalysis.Operations.CommonConversion"]);
        var generatedFilePath = GetGeneratedFilePath("Operations", "CommonConversionEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestCommonConversion_V3_8_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for struct Microsoft.CodeAnalysis.Operations.CommonConversion.</summary>
    public static partial class CommonConversionEx
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.Operations.CommonConversion"";

        private delegate global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToTypeGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj);

        private static readonly ConstrainedToTypeGetterDelegate ConstrainedToTypeGetterFunc;

        static CommonConversionEx()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            ConstrainedToTypeGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<ConstrainedToTypeGetterDelegate>(wrappedType, nameof(ConstrainedToType));
        }

        /// <summary>Property added in version 4.3.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToType(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
        {
            return ConstrainedToTypeGetterFunc(_obj);
        }
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.8.0.0", ["Microsoft.CodeAnalysis.Operations.CommonConversion"]);
        var generatedFilePath = GetGeneratedFilePath("Operations", "CommonConversionEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestCommonConversion_V3_8_0_0_CSharp7_3()
    {
        var source = @"// <auto-generated/>


namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for struct Microsoft.CodeAnalysis.Operations.CommonConversion.</summary>
    public static partial class CommonConversionEx
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.Operations.CommonConversion"";

        private delegate global::Microsoft.CodeAnalysis.ITypeSymbol ConstrainedToTypeGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj);

        private static readonly ConstrainedToTypeGetterDelegate ConstrainedToTypeGetterFunc;

        static CommonConversionEx()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            ConstrainedToTypeGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<ConstrainedToTypeGetterDelegate>(wrappedType, nameof(ConstrainedToType));
        }

        /// <summary>Property added in version 4.3.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ITypeSymbol ConstrainedToType(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
        {
            return ConstrainedToTypeGetterFunc(_obj);
        }
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.8.0.0", ["Microsoft.CodeAnalysis.Operations.CommonConversion"], LanguageVersion.CSharp7_3);
        var generatedFilePath = GetGeneratedFilePath("Operations", "CommonConversionEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestBinaryOperatorKind_V3_0_0_0()
    {
        var source = @"// <auto-generated/>

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for enum Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.</summary>
    public static partial class BinaryOperatorKindEx
    {
        /// <summary>Added in version 4.3.0.0.</summary>
        public const global::Microsoft.CodeAnalysis.Operations.BinaryOperatorKind UnsignedRightShift = (global::Microsoft.CodeAnalysis.Operations.BinaryOperatorKind)25;
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.0.0.0", ["Microsoft.CodeAnalysis.Operations.BinaryOperatorKind"]);
        var generatedFilePath = GetGeneratedFilePath("Operations", "BinaryOperatorKindEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestBinaryOperatorKind_V4_4_0_0()
    {
        var test = CreateTest(AssemblyKind.Common, "4.4.0.0", ["Microsoft.CodeAnalysis.Operations.BinaryOperatorKind"]);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestGeneratedKind_V3_0_0_0()
    {
        var source = @"// <auto-generated/>

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for enum Microsoft.CodeAnalysis.GeneratedKind. Added in version 3.8.0.0.</summary>
    public enum GeneratedKindEx : global::System.Int32
    {
        /// <summary>Added in version 3.8.0.0.</summary>
        Unknown = 0,

        /// <summary>Added in version 3.8.0.0.</summary>
        NotGenerated = 1,

        /// <summary>Added in version 3.8.0.0.</summary>
        MarkedGenerated = 2,
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.0.0.0", ["Microsoft.CodeAnalysis.GeneratedKind"]);
        var generatedFilePath = GetGeneratedFilePath("GeneratedKindEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestGeneratedKind_V3_8_0_0()
    {
        var test = CreateTest(AssemblyKind.Common, "3.8.0.0", ["Microsoft.CodeAnalysis.GeneratedKind"]);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestSourceGeneratedDocument_V3_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for class Microsoft.CodeAnalysis.SourceGeneratedDocument. Added in version 3.9.0.0.</summary>
    public partial struct SourceGeneratedDocumentWrapper
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.SourceGeneratedDocument"";

        private static readonly global::System.Type? WrappedType;

        private delegate global::System.String HintNameGetterDelegate(global::Microsoft.CodeAnalysis.Document _obj);

        private static readonly HintNameGetterDelegate HintNameGetterFunc;

        private readonly global::Microsoft.CodeAnalysis.Document wrappedObject;

        static SourceGeneratedDocumentWrapper()
        {
            WrappedType = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.FindType(WrappedTypeName);

            HintNameGetterFunc = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.CreateInstanceGetAccessor<HintNameGetterDelegate>(WrappedType, nameof(HintName));
        }

        private SourceGeneratedDocumentWrapper(global::Microsoft.CodeAnalysis.Document obj)
        {
            wrappedObject = obj;
        }

        /// <summary>Property added in version 3.9.0.0.</summary>
        public global::System.String HintName
        {
            get { return HintNameGetterFunc(wrappedObject); }
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, an exception will be thrown.</summary>
        public static explicit operator SourceGeneratedDocumentWrapper(global::Microsoft.CodeAnalysis.Document obj)
        {
            return Wrap(obj);
        }

        /// <summary>Returns the wrapped object.</summary>
        public static implicit operator global::Microsoft.CodeAnalysis.Document(SourceGeneratedDocumentWrapper obj)
        {
            return obj.Unwrap();
        }

        /// <summary>Returns true if the specified object is compatible with this wrapper.</summary>
        public static bool Is(global::Microsoft.CodeAnalysis.Document? obj)
        {
            return global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.Is(obj, WrappedType);
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, an exception will be thrown.</summary>
        public static SourceGeneratedDocumentWrapper Wrap(global::Microsoft.CodeAnalysis.Document obj)
        {
            var obj2 = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.Wrap<global::Microsoft.CodeAnalysis.Document>(obj, WrappedType);
            return new SourceGeneratedDocumentWrapper(obj2);
        }

        /// <summary>Returns the wrapped object.</summary>
        public global::Microsoft.CodeAnalysis.Document Unwrap()
        {
            return wrappedObject;
        }
    }
}
";

        var test = CreateTest(AssemblyKind.WorkspacesCommon, "3.0.0.0", ["Microsoft.CodeAnalysis.SourceGeneratedDocument"]);
        var generatedFilePath = GetGeneratedFilePath("SourceGeneratedDocumentWrapper.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestSourceGeneratedDocument_V4_4_0_0()
    {
        var test = CreateTest(AssemblyKind.WorkspacesCommon, "4.4.0.0", ["Microsoft.CodeAnalysis.SourceGeneratedDocument"]);
        await test.RunAsync();
    }

    // TODO: Add a test that includes removed members
    // NOTE: A property was added in 4.1.0.0 but later on removed again
    [TestMethod]
    public async Task TestParameterSyntax_V3_0_0_0()
    {
        var test = CreateTest(AssemblyKind.CSharp, "3.0.0.0", ["Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax"]);
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "SeparatedSyntaxListWrapper.g.cs", SourceText.From(SeparatedSyntaxListWrapperSource, Encoding.UTF8)));
        await test.RunAsync();
    }

    // TODO: Add a test that includes removed types
    // NOTE: The type was added in 3.1.0.0 but later on removed again
    [TestMethod]
    public async Task TestBaseExpressionTypeClauseSyntax_V3_0_0_0()
    {
        var test = CreateTest(AssemblyKind.CSharp, "3.0.0.0", ["Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionTypeClauseSyntax"]);
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "SeparatedSyntaxListWrapper.g.cs", SourceText.From(SeparatedSyntaxListWrapperSource, Encoding.UTF8)));
        await test.RunAsync();
    }

    // TODO: Add a test that includes removed members
    // NOTE: A method was added in 4.3.0.0 but later on removed again
    [TestMethod]
    public async Task TestModuleMetadata_V3_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for class Microsoft.CodeAnalysis.ModuleMetadata.</summary>
    public static partial class ModuleMetadataEx
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.ModuleMetadata"";

        private delegate global::Microsoft.CodeAnalysis.ModuleMetadata CreateFromMetadataDelegate0(global::System.IntPtr metadata, global::System.Int32 size, global::System.Action onDispose);

        private static readonly CreateFromMetadataDelegate0 CreateFromMetadataFunc0;

        static ModuleMetadataEx()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            CreateFromMetadataFunc0 = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateStaticMethodAccessor<CreateFromMetadataDelegate0>(wrappedType, ""CreateFromMetadata"", ""metadataIntPtr"", ""sizeInt32"", ""onDisposeAction"");
        }

        /// <summary>Method added in version 4.4.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ModuleMetadata CreateFromMetadata(global::System.IntPtr metadata, global::System.Int32 size, global::System.Action onDispose)
        {
            return CreateFromMetadataFunc0(metadata, size, onDispose);
        }
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.0.0.0", ["Microsoft.CodeAnalysis.ModuleMetadata"]);
        var generatedFilePath = GetGeneratedFilePath("ModuleMetadataEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    // TODO: Add a test that includes removed values
    // NOTE: Values were added in 3.1.0.0 but later on removed again
    [TestMethod]
    public async Task TestNullableAnnotation_V3_0_0_0()
    {
        var source = @"// <auto-generated/>

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for enum Microsoft.CodeAnalysis.NullableAnnotation. Added in version 3.1.0.0.</summary>
    public enum NullableAnnotationEx : global::System.Byte
    {
        /// <summary>Added in version 3.3.0.0.</summary>
        None = 0,

        /// <summary>Added in version 3.3.0.0.</summary>
        NotAnnotated = 1,

        /// <summary>Added in version 3.3.0.0.</summary>
        Annotated = 2,
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.0.0.0", ["Microsoft.CodeAnalysis.NullableAnnotation"]);
        var generatedFilePath = GetGeneratedFilePath("NullableAnnotationEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    // TODO: Add a test that includes removed values
    // NOTE: Values were added in 3.1.0.0 but later on removed again
    [TestMethod]
    public async Task TestIConstructorBodyOperation_V2_6_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for interface Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation. Added in version 2.8.0.0.</summary>
    public partial struct IConstructorBodyOperationWrapper
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation"";

        private static readonly global::System.Type? WrappedType;

        private delegate global::Microsoft.CodeAnalysis.IOperation? InitializerGetterDelegate(global::System.Object _obj);
        private delegate global::System.Collections.Immutable.ImmutableArray<global::Microsoft.CodeAnalysis.ILocalSymbol> LocalsGetterDelegate(global::System.Object _obj);

        private static readonly InitializerGetterDelegate InitializerGetterFunc;
        private static readonly LocalsGetterDelegate LocalsGetterFunc;

        private readonly global::System.Object wrappedObject;

        static IConstructorBodyOperationWrapper()
        {
            WrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            InitializerGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<InitializerGetterDelegate>(WrappedType, nameof(Initializer));
            LocalsGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<LocalsGetterDelegate>(WrappedType, nameof(Locals));
        }

        private IConstructorBodyOperationWrapper(global::System.Object obj)
        {
            wrappedObject = obj;
        }

        /// <summary>Property added in version 2.8.0.0.</summary>
        public global::Microsoft.CodeAnalysis.IOperation? Initializer
        {
            get { return InitializerGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 2.8.0.0.</summary>
        public global::System.Collections.Immutable.ImmutableArray<global::Microsoft.CodeAnalysis.ILocalSymbol> Locals
        {
            get { return LocalsGetterFunc(wrappedObject); }
        }

        /// <summary>Returns true if the specified object is compatible with this wrapper.</summary>
        public static bool Is(global::System.Object? obj)
        {
            return global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.Is(obj, WrappedType);
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, an exception will be thrown.</summary>
        public static IConstructorBodyOperationWrapper Wrap(global::System.Object obj)
        {
            var obj2 = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.Wrap<global::System.Object>(obj, WrappedType);
            return new IConstructorBodyOperationWrapper(obj2);
        }

        /// <summary>Returns the wrapped object.</summary>
        public global::System.Object Unwrap()
        {
            return wrappedObject;
        }
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "2.6.0.0", ["Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation"]);
        var generatedFilePath = GetGeneratedFilePath("Operations", "IConstructorBodyOperationWrapper.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    // NOTE: Added in 2.0.0.0, so nothing should be generated
    [TestMethod]
    public async Task TestDocumentActiveContextChangedEventArgs_V3_0_0_0()
    {
        var test = CreateTest(AssemblyKind.WorkspacesCommon, "3.0.0.0", ["Microsoft.CodeAnalysis.DocumentActiveContextChangedEventArgs"]);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestDocumentActiveContextChangedEventArgs_V0_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for class Microsoft.CodeAnalysis.DocumentActiveContextChangedEventArgs. Added in version 2.0.0.0.</summary>
    public partial struct DocumentActiveContextChangedEventArgsWrapper
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.DocumentActiveContextChangedEventArgs"";

        private static readonly global::System.Type? WrappedType;

        private delegate DocumentActiveContextChangedEventArgsWrapper ConstructorDelegate0(global::Microsoft.CodeAnalysis.Solution? solution, global::Microsoft.CodeAnalysis.Text.SourceTextContainer? sourceTextContainer, global::Microsoft.CodeAnalysis.DocumentId? oldActiveContextDocumentId, global::Microsoft.CodeAnalysis.DocumentId? newActiveContextDocumentId);

        private delegate global::Microsoft.CodeAnalysis.DocumentId? NewActiveContextDocumentIdGetterDelegate(global::System.EventArgs _obj);
        private delegate global::Microsoft.CodeAnalysis.DocumentId? OldActiveContextDocumentIdGetterDelegate(global::System.EventArgs _obj);
        private delegate global::Microsoft.CodeAnalysis.Solution? SolutionGetterDelegate(global::System.EventArgs _obj);
        private delegate global::Microsoft.CodeAnalysis.Text.SourceTextContainer? SourceTextContainerGetterDelegate(global::System.EventArgs _obj);

        private static readonly ConstructorDelegate0 ConstructorFunc0;

        private static readonly NewActiveContextDocumentIdGetterDelegate NewActiveContextDocumentIdGetterFunc;
        private static readonly OldActiveContextDocumentIdGetterDelegate OldActiveContextDocumentIdGetterFunc;
        private static readonly SolutionGetterDelegate SolutionGetterFunc;
        private static readonly SourceTextContainerGetterDelegate SourceTextContainerGetterFunc;

        private readonly global::System.EventArgs wrappedObject;

        static DocumentActiveContextChangedEventArgsWrapper()
        {
            WrappedType = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.FindType(WrappedTypeName);

            ConstructorFunc0 = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.CreateInstanceConstructorAccessor<ConstructorDelegate0>(WrappedType, ""solutionSolution"", ""sourceTextContainerSourceTextContainer"", ""oldActiveContextDocumentIdDocumentId"", ""newActiveContextDocumentIdDocumentId"");

            NewActiveContextDocumentIdGetterFunc = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.CreateInstanceGetAccessor<NewActiveContextDocumentIdGetterDelegate>(WrappedType, nameof(NewActiveContextDocumentId));
            OldActiveContextDocumentIdGetterFunc = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.CreateInstanceGetAccessor<OldActiveContextDocumentIdGetterDelegate>(WrappedType, nameof(OldActiveContextDocumentId));
            SolutionGetterFunc = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.CreateInstanceGetAccessor<SolutionGetterDelegate>(WrappedType, nameof(Solution));
            SourceTextContainerGetterFunc = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.CreateInstanceGetAccessor<SourceTextContainerGetterDelegate>(WrappedType, nameof(SourceTextContainer));
        }

        private DocumentActiveContextChangedEventArgsWrapper(global::System.EventArgs obj)
        {
            wrappedObject = obj;
        }

        /// <summary>Constructor added in version 2.0.0.0.</summary>
        public static DocumentActiveContextChangedEventArgsWrapper Create(global::Microsoft.CodeAnalysis.Solution? solution, global::Microsoft.CodeAnalysis.Text.SourceTextContainer? sourceTextContainer, global::Microsoft.CodeAnalysis.DocumentId? oldActiveContextDocumentId, global::Microsoft.CodeAnalysis.DocumentId? newActiveContextDocumentId)
        {
            return ConstructorFunc0(solution, sourceTextContainer, oldActiveContextDocumentId, newActiveContextDocumentId);
        }

        /// <summary>Property added in version 2.0.0.0.</summary>
        public global::Microsoft.CodeAnalysis.DocumentId? NewActiveContextDocumentId
        {
            get { return NewActiveContextDocumentIdGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 2.0.0.0.</summary>
        public global::Microsoft.CodeAnalysis.DocumentId? OldActiveContextDocumentId
        {
            get { return OldActiveContextDocumentIdGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 2.0.0.0.</summary>
        public global::Microsoft.CodeAnalysis.Solution? Solution
        {
            get { return SolutionGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 2.0.0.0.</summary>
        public global::Microsoft.CodeAnalysis.Text.SourceTextContainer? SourceTextContainer
        {
            get { return SourceTextContainerGetterFunc(wrappedObject); }
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, an exception will be thrown.</summary>
        public static explicit operator DocumentActiveContextChangedEventArgsWrapper(global::System.EventArgs obj)
        {
            return Wrap(obj);
        }

        /// <summary>Returns the wrapped object.</summary>
        public static implicit operator global::System.EventArgs(DocumentActiveContextChangedEventArgsWrapper obj)
        {
            return obj.Unwrap();
        }

        /// <summary>Returns true if the specified object is compatible with this wrapper.</summary>
        public static bool Is(global::System.EventArgs? obj)
        {
            return global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.Is(obj, WrappedType);
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, an exception will be thrown.</summary>
        public static DocumentActiveContextChangedEventArgsWrapper Wrap(global::System.EventArgs obj)
        {
            var obj2 = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.Wrap<global::System.EventArgs>(obj, WrappedType);
            return new DocumentActiveContextChangedEventArgsWrapper(obj2);
        }

        /// <summary>Returns the wrapped object.</summary>
        public global::System.EventArgs Unwrap()
        {
            return wrappedObject;
        }
    }
}
";

        var test = CreateTest(AssemblyKind.WorkspacesCommon, "0.0.0.0", ["Microsoft.CodeAnalysis.DocumentActiveContextChangedEventArgs"]);
        var generatedFilePath = GetGeneratedFilePath("DocumentActiveContextChangedEventArgsWrapper.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestListPatternSyntax_V3_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.CSharp.Syntax.Lightup
{
    /// <summary>Provides lightup support for class Microsoft.CodeAnalysis.CSharp.Syntax.ListPatternSyntax. Added in version 4.1.0.0.</summary>
    public partial struct ListPatternSyntaxWrapper
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.CSharp.Syntax.ListPatternSyntax"";

        private static readonly global::System.Type? WrappedType;

        private delegate global::Microsoft.CodeAnalysis.SyntaxToken CloseBracketTokenGetterDelegate(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj);
        private delegate global::Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? DesignationGetterDelegate(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj);
        private delegate global::Microsoft.CodeAnalysis.SyntaxToken OpenBracketTokenGetterDelegate(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj);
        private delegate global::Microsoft.CodeAnalysis.SeparatedSyntaxList<global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax> PatternsGetterDelegate(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj);

        private delegate void AcceptDelegate0(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj, global::Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor);
        private delegate global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper AddPatternsDelegate1(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj, params global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax[] items);
        private delegate global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper UpdateDelegate2(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj, global::Microsoft.CodeAnalysis.SyntaxToken openBracketToken, global::Microsoft.CodeAnalysis.SeparatedSyntaxList<global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax> patterns, global::Microsoft.CodeAnalysis.SyntaxToken closeBracketToken, global::Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? designation);
        private delegate global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithCloseBracketTokenDelegate3(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj, global::Microsoft.CodeAnalysis.SyntaxToken closeBracketToken);
        private delegate global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithDesignationDelegate4(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj, global::Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? designation);
        private delegate global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithOpenBracketTokenDelegate5(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj, global::Microsoft.CodeAnalysis.SyntaxToken openBracketToken);
        private delegate global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithPatternsDelegate6(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj, global::Microsoft.CodeAnalysis.SeparatedSyntaxList<global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax> patterns);

        private static readonly CloseBracketTokenGetterDelegate CloseBracketTokenGetterFunc;
        private static readonly DesignationGetterDelegate DesignationGetterFunc;
        private static readonly OpenBracketTokenGetterDelegate OpenBracketTokenGetterFunc;
        private static readonly PatternsGetterDelegate PatternsGetterFunc;

        private static readonly AcceptDelegate0 AcceptFunc0;
        private static readonly AddPatternsDelegate1 AddPatternsFunc1;
        private static readonly UpdateDelegate2 UpdateFunc2;
        private static readonly WithCloseBracketTokenDelegate3 WithCloseBracketTokenFunc3;
        private static readonly WithDesignationDelegate4 WithDesignationFunc4;
        private static readonly WithOpenBracketTokenDelegate5 WithOpenBracketTokenFunc5;
        private static readonly WithPatternsDelegate6 WithPatternsFunc6;

        private readonly global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax wrappedObject;

        static ListPatternSyntaxWrapper()
        {
            WrappedType = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.FindType(WrappedTypeName);

            CloseBracketTokenGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<CloseBracketTokenGetterDelegate>(WrappedType, nameof(CloseBracketToken));
            DesignationGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<DesignationGetterDelegate>(WrappedType, nameof(Designation));
            OpenBracketTokenGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<OpenBracketTokenGetterDelegate>(WrappedType, nameof(OpenBracketToken));
            PatternsGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<PatternsGetterDelegate>(WrappedType, nameof(Patterns));

            AcceptFunc0 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<AcceptDelegate0>(WrappedType, ""Accept"", ""visitorCSharpSyntaxVisitor"");
            AddPatternsFunc1 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<AddPatternsDelegate1>(WrappedType, ""AddPatterns"", ""itemsPatternSyntax[]"");
            UpdateFunc2 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<UpdateDelegate2>(WrappedType, ""Update"", ""openBracketTokenSyntaxToken"", ""patternsSeparatedSyntaxList`1"", ""closeBracketTokenSyntaxToken"", ""designationVariableDesignationSyntax"");
            WithCloseBracketTokenFunc3 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<WithCloseBracketTokenDelegate3>(WrappedType, ""WithCloseBracketToken"", ""closeBracketTokenSyntaxToken"");
            WithDesignationFunc4 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<WithDesignationDelegate4>(WrappedType, ""WithDesignation"", ""designationVariableDesignationSyntax"");
            WithOpenBracketTokenFunc5 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<WithOpenBracketTokenDelegate5>(WrappedType, ""WithOpenBracketToken"", ""openBracketTokenSyntaxToken"");
            WithPatternsFunc6 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<WithPatternsDelegate6>(WrappedType, ""WithPatterns"", ""patternsSeparatedSyntaxList`1"");
        }

        private ListPatternSyntaxWrapper(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax obj)
        {
            wrappedObject = obj;
        }

        /// <summary>Property added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken
        {
            get { return CloseBracketTokenGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? Designation
        {
            get { return DesignationGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken
        {
            get { return OpenBracketTokenGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.SeparatedSyntaxList<global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax> Patterns
        {
            get { return PatternsGetterFunc(wrappedObject); }
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, an exception will be thrown.</summary>
        public static explicit operator ListPatternSyntaxWrapper(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax obj)
        {
            return Wrap(obj);
        }

        /// <summary>Returns the wrapped object.</summary>
        public static implicit operator global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax(ListPatternSyntaxWrapper obj)
        {
            return obj.Unwrap();
        }

        /// <summary>Returns true if the specified object is compatible with this wrapper.</summary>
        public static bool Is(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax? obj)
        {
            return global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.Is(obj, WrappedType);
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, an exception will be thrown.</summary>
        public static ListPatternSyntaxWrapper Wrap(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax obj)
        {
            var obj2 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.Wrap<global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax>(obj, WrappedType);
            return new ListPatternSyntaxWrapper(obj2);
        }

        /// <summary>Returns the wrapped object.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax Unwrap()
        {
            return wrappedObject;
        }

        /// <summary>Method added in version 4.1.0.0.</summary>
        public void Accept(global::Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor)
        {
            AcceptFunc0(wrappedObject, visitor);
        }

        /// <summary>Method added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper AddPatterns(params global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax[] items)
        {
            return AddPatternsFunc1(wrappedObject, items);
        }

        /// <summary>Method added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper Update(global::Microsoft.CodeAnalysis.SyntaxToken openBracketToken, global::Microsoft.CodeAnalysis.SeparatedSyntaxList<global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax> patterns, global::Microsoft.CodeAnalysis.SyntaxToken closeBracketToken, global::Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? designation)
        {
            return UpdateFunc2(wrappedObject, openBracketToken, patterns, closeBracketToken, designation);
        }

        /// <summary>Method added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithCloseBracketToken(global::Microsoft.CodeAnalysis.SyntaxToken closeBracketToken)
        {
            return WithCloseBracketTokenFunc3(wrappedObject, closeBracketToken);
        }

        /// <summary>Method added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithDesignation(global::Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? designation)
        {
            return WithDesignationFunc4(wrappedObject, designation);
        }

        /// <summary>Method added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithOpenBracketToken(global::Microsoft.CodeAnalysis.SyntaxToken openBracketToken)
        {
            return WithOpenBracketTokenFunc5(wrappedObject, openBracketToken);
        }

        /// <summary>Method added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithPatterns(global::Microsoft.CodeAnalysis.SeparatedSyntaxList<global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax> patterns)
        {
            return WithPatternsFunc6(wrappedObject, patterns);
        }
    }
}
";

        var test = CreateTest(AssemblyKind.CSharp, "3.0.0.0", ["Microsoft.CodeAnalysis.CSharp.Syntax.ListPatternSyntax"]);
        var generatedFilePath = GetGeneratedFilePath("CSharp", "Syntax", "ListPatternSyntaxWrapper.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "SeparatedSyntaxListWrapper.g.cs", SourceText.From(SeparatedSyntaxListWrapperSource, Encoding.UTF8)));
        await test.RunAsync();
    }

    protected virtual string GetGeneratedFilePath(params string[] parts)
    {
        var result = $"Microsoft.CodeAnalysis.{string.Join(".", parts)}";
        return result;
    }

    private static CSharpSourceGeneratorTest<LightupGenerator, DefaultVerifier> CreateTest(
        AssemblyKind? assemblyKind,
        string? baselineVersion,
        List<string> typesToInclude,
        LanguageVersion? languageVersion = null,
        bool? useFoldersInFilePaths = null,
        bool shouldGeneratedFiles = true)
    {
        var na = (languageVersion == null || languageVersion >= LanguageVersion.CSharp8) ? "?" : "";
        useFoldersInFilePaths ??= Helpers.RoslynSupportsFoldersInGeneratedFilePaths;

        var lightupHelperSource = $@"
namespace CodeAnalysis.Lightup.Runtime
{{
    using System;
    using System.Reflection;
    
    public class LightupHelper
    {{
        public static Type{na} FindType(Assembly assembly, string wrappedTypeName)
            => throw new Exception();
        
        public static bool Is(object{na} obj, Type{na} wrappedType)
            => throw new Exception();
        
        public static TObject{na} Wrap<TObject>(object{na} obj, Type{na} wrappedType)
            where TObject : class
            => throw new Exception();        
        
        public static TDelegate CreateInstanceConstructorAccessor<TDelegate>(Type{na} wrappedType, params string[] paramTags)
            where TDelegate : Delegate
            => throw new Exception();
        
        public static TDelegate CreateInstanceGetAccessor<TDelegate>(Type{na} wrappedType, string memberName)
            where TDelegate : Delegate
            => throw new Exception();
        
        public static TDelegate CreateStaticMethodAccessor<TDelegate>(Type{na} wrappedType, string memberName, params string[] paramTags)
            where TDelegate : Delegate
            => throw new Exception();
        
        public static TDelegate CreateInstanceMethodAccessor<TDelegate>(Type{na} wrappedType, string memberName, params string[] paramTags)
            where TDelegate : Delegate
            => throw new Exception();
    }}
}}";

        var specificLightupHelperSource = $@"
// <auto-generated/>
{(languageVersion == null || languageVersion >= LanguageVersion.CSharp8 ? "#nullable enable" : "")}

namespace Microsoft.CodeAnalysis.Lightup
{{
    internal class {assemblyKind}LightupHelper : global::CodeAnalysis.Lightup.Runtime.LightupHelper
    {{
        private static readonly global::System.Reflection.Assembly Assembly = typeof(global::{ExampleTypeNames[assemblyKind ?? AssemblyKind.Common]}).Assembly;

        public static global::System.Type{na} FindType(string wrappedTypeName)
        {{
            return FindType(Assembly, wrappedTypeName);
        }}
    }}
}}
";

        var test = new CSharpSourceGeneratorTest<LightupGenerator, DefaultVerifier>()
        {
            TestState =
            {
                Sources = { lightupHelperSource },
            },
            ReferenceAssemblies = CreateReferenceAssemblies(),
        };

        if (shouldGeneratedFiles)
        {
            test.TestState.GeneratedSources.Add((typeof(LightupGenerator), $"{assemblyKind}LightupHelper.g.cs", SourceText.From(specificLightupHelperSource, Encoding.UTF8)));
        }

        test.SolutionTransforms.Add((solution, projectId) =>
        {
            if (languageVersion != null)
            {
                var project = solution.GetProject(projectId);
                var parseOptions = ((CSharpParseOptions)project!.ParseOptions!).WithLanguageVersion(languageVersion.Value);
                solution = solution.WithProjectParseOptions(projectId, parseOptions);
            }

            return solution;
        });

        var configFileContent = $@"{{
	{(assemblyKind != null ? $@"""assemblies"": [ ""{(assemblyKind != null ? AssemblyKindStrings[assemblyKind.Value] : "")}"" ]," : "")}
	{(baselineVersion != null ? $@"""baselineVersion"": ""{baselineVersion}""," : "")}
    ""includeTypes"": [ {string.Join(", ", typesToInclude.Select(x => $@"""{x}"""))} ],
    ""useFoldersInFilePaths"": {(useFoldersInFilePaths.Value ? "true" : "false")}
}}";
        test.TestState.AdditionalFiles.Add(("CodeAnalysis.Lightup.json", configFileContent));

        return test;
    }

    private static ReferenceAssemblies CreateReferenceAssemblies()
    {
        return ReferenceAssemblies.Net.Net80
            .AddPackages([new PackageIdentity("Microsoft.CodeAnalysis", "3.0.0")]);
    }
}
