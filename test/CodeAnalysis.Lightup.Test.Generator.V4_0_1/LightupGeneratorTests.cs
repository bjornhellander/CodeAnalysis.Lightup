// Copyright © Björn Hellander 2024
// Licensed under the MIT License. See LICENSE.txt in the repository root for license information.

namespace CodeAnalysis.Lightup.Test.Generator.V4_0_1;

using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CodeAnalysis.Lightup.Definitions;
using CodeAnalysis.Lightup.Generator;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Testing;
using Microsoft.CodeAnalysis.Testing;
using Microsoft.CodeAnalysis.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;

[TestClass]
public class LightupGeneratorTests
{
    private const string SeparatedSyntaxListWrapperSource = @"
// <auto-generated/>
#pragma warning disable CS1591
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    // TODO: Implement remaining members
    public struct SeparatedSyntaxListWrapper<TNode>
    {
        private static readonly global::System.Type? WrappedType; // NOTE: Possibly used via reflection

        private delegate int CountDelegate(object? obj);
        private delegate SeparatedSyntaxListWrapper<TNode> AddRangeDelegate(object? obj, global::System.Collections.Generic.IEnumerable<TNode> arg1);

        private static readonly CountDelegate CountAccessor;
        private static readonly AddRangeDelegate AddRangeAccessor;

        private readonly object? wrappedObject;

        static SeparatedSyntaxListWrapper()
        {
            var wrapperNodeType = typeof(TNode);
            var wrappedNodeTypeField = wrapperNodeType.GetField(""WrappedType"", global::System.Reflection.BindingFlags.Static | global::System.Reflection.BindingFlags.NonPublic);
            var wrappedNodeType = (global::System.Type)wrappedNodeTypeField.GetValue(null);
            WrappedType = wrappedNodeType != null ? typeof(SeparatedSyntaxList<>).MakeGenericType(wrappedNodeType) : null;

            CountAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<CountDelegate>(WrappedType, nameof(Count));
            AddRangeAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<AddRangeDelegate>(WrappedType, nameof(AddRange), ""nodesIEnumerable`1"");
        }

        private SeparatedSyntaxListWrapper(object? obj)
        {
            wrappedObject = obj;
        }

        public int Count
        {
            get { return CountAccessor(wrappedObject); }
        }

        public int SeparatorCount
        {
            get { throw new global::System.NotImplementedException(); }
        }

        public global::Microsoft.CodeAnalysis.Text.TextSpan FullSpan
        {
             get { throw new global::System.NotImplementedException(); }
        }

        public global::Microsoft.CodeAnalysis.Text.TextSpan Span
        {
             get { throw new global::System.NotImplementedException(); }
        }

        public TNode this[int index]
        {
             get { throw new global::System.NotImplementedException(); }
        }

        public static implicit operator SeparatedSyntaxListWrapper<SyntaxNode>(SeparatedSyntaxListWrapper<TNode> nodes)
        {
             throw new global::System.NotImplementedException();
        }

        public static implicit operator SeparatedSyntaxListWrapper<TNode>(SeparatedSyntaxListWrapper<SyntaxNode> nodes)
        {
             throw new global::System.NotImplementedException();
        }

        public static bool Is(object? obj)
        {
            if (obj != null && obj.GetType() != WrappedType)
            {
                obj = null;
            }

            return obj != null;
        }

        public static SeparatedSyntaxListWrapper<TNode> Wrap(object? obj)
        {
            if (obj != null && obj.GetType() != WrappedType)
            {
                obj = null;
            }

            return new SeparatedSyntaxListWrapper<TNode>(obj);
        }

        public object? Unwrap()
        {
             return wrappedObject;
        }

        public global::Microsoft.CodeAnalysis.SyntaxToken GetSeparator(int index)
        {
             throw new global::System.NotImplementedException();
        }

        public global::System.Collections.Generic.IEnumerable<global::Microsoft.CodeAnalysis.SyntaxToken> GetSeparators()
        {
             throw new global::System.NotImplementedException();
        }

        public override string ToString()
        {
             throw new global::System.NotImplementedException();
        }

        public string ToFullString()
        {
             throw new global::System.NotImplementedException();
        }

        public TNode First()
        {
             throw new global::System.NotImplementedException();
        }

        public TNode FirstOrDefault()
        {
            throw new global::System.NotImplementedException();
        }

        public TNode Last()
        {
             throw new global::System.NotImplementedException();
        }

        public TNode LastOrDefault()
        {
             throw new global::System.NotImplementedException();
        }

        public bool Contains(TNode node)
        {
             throw new global::System.NotImplementedException();
        }

        public int IndexOf(TNode node)
        {
             throw new global::System.NotImplementedException();
        }

        public int IndexOf(global::System.Func<TNode, bool> predicate)
        {
             throw new global::System.NotImplementedException();
        }

        public int LastIndexOf(TNode node)
        {
             throw new global::System.NotImplementedException();
        }

        public int LastIndexOf(global::System.Func<TNode, bool> predicate)
        {
             throw new global::System.NotImplementedException();
        }

        public bool Any()
        {
             throw new global::System.NotImplementedException();
        }

        public SyntaxNodeOrTokenList GetWithSeparators()
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> Add(TNode node)
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> AddRange(global::System.Collections.Generic.IEnumerable<TNode> nodes)
        {
             return AddRangeAccessor(wrappedObject, nodes);
        }

        public SeparatedSyntaxListWrapper<TNode> Insert(int index, TNode node)
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> InsertRange(int index, global::System.Collections.Generic.IEnumerable<TNode> nodes)
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> RemoveAt(int index)
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> Remove(TNode node)
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> Replace(TNode nodeInList, TNode newNode)
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> ReplaceRange(TNode nodeInList, global::System.Collections.Generic.IEnumerable<TNode> newNodes)
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> ReplaceSeparator(global::Microsoft.CodeAnalysis.SyntaxToken separatorToken, global::Microsoft.CodeAnalysis.SyntaxToken newSeparator)
        {
             throw new global::System.NotImplementedException();
        }
    }
}
";

    private static readonly Dictionary<AssemblyKind, string> ExampleTypeNames = new()
    {
        [AssemblyKind.Common] = "Microsoft.CodeAnalysis.IOperation",
        [AssemblyKind.CSharp] = "Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax",
        [AssemblyKind.WorkspacesCommon] = "Microsoft.CodeAnalysis.WorkspaceChangeKind",
    };

    protected virtual bool SupportsFoldersInFilePaths => false;

    [TestMethod]
    public async Task TestNoAssemblyKindInConfigurationFile()
    {
        var test = CreateTest(null, "3.3.0.0", [""], shouldGeneratedFiles: false);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestNoBaselineVersionInConfigurationFile()
    {
        var test = CreateTest(AssemblyKind.Common, null, [""], shouldGeneratedFiles: false);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestUnsupportedFoldersInFilePaths()
    {
        if (SupportsFoldersInFilePaths)
        {
            return;
        }

        var test = CreateTest(AssemblyKind.Common, "3.3.0.0", [""], useFoldersInFilePaths: true, shouldGeneratedFiles: false);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestSeparatedSyntaxListWrapper()
    {
        var source = SeparatedSyntaxListWrapperSource;

        var test = CreateTest(AssemblyKind.CSharp, "3.0.0.0", [""]);
        var generatedFilePath = "SeparatedSyntaxListWrapper.g.cs";
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestCommonConversion_V3_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for struct Microsoft.CodeAnalysis.Operations.CommonConversion.</summary>
    public static partial class CommonConversionExtensions
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.Operations.CommonConversion"";

        private delegate global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToTypeGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion? _obj);
        private delegate global::System.Boolean IsNullableGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion? _obj);

        private static readonly ConstrainedToTypeGetterDelegate ConstrainedToTypeGetterFunc;
        private static readonly IsNullableGetterDelegate IsNullableGetterFunc;

        static CommonConversionExtensions()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            ConstrainedToTypeGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<ConstrainedToTypeGetterDelegate>(wrappedType, nameof(ConstrainedToType));
            IsNullableGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<IsNullableGetterDelegate>(wrappedType, nameof(IsNullable));
        }

        /// <summary>Property added in version 4.3.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToType(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
        {
            return ConstrainedToTypeGetterFunc(_obj);
        }

        /// <summary>Property added in version 3.7.0.0.</summary>
        public static global::System.Boolean IsNullable(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
        {
            return IsNullableGetterFunc(_obj);
        }
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.3.0.0", ["Microsoft.CodeAnalysis.Operations.CommonConversion"]);
        var generatedFilePath = GetGeneratedFilePath("Operations", "CommonConversionExtensions.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestCommonConversion_V3_8_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for struct Microsoft.CodeAnalysis.Operations.CommonConversion.</summary>
    public static partial class CommonConversionExtensions
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.Operations.CommonConversion"";

        private delegate global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToTypeGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion? _obj);

        private static readonly ConstrainedToTypeGetterDelegate ConstrainedToTypeGetterFunc;

        static CommonConversionExtensions()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            ConstrainedToTypeGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<ConstrainedToTypeGetterDelegate>(wrappedType, nameof(ConstrainedToType));
        }

        /// <summary>Property added in version 4.3.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToType(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
        {
            return ConstrainedToTypeGetterFunc(_obj);
        }
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.8.0.0", ["Microsoft.CodeAnalysis.Operations.CommonConversion"]);
        var generatedFilePath = GetGeneratedFilePath("Operations", "CommonConversionExtensions.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestCommonConversion_V3_8_0_0_CSharp7_3()
    {
        var source = @"// <auto-generated/>


namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for struct Microsoft.CodeAnalysis.Operations.CommonConversion.</summary>
    public static partial class CommonConversionExtensions
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.Operations.CommonConversion"";

        private delegate global::Microsoft.CodeAnalysis.ITypeSymbol ConstrainedToTypeGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj);

        private static readonly ConstrainedToTypeGetterDelegate ConstrainedToTypeGetterFunc;

        static CommonConversionExtensions()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            ConstrainedToTypeGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<ConstrainedToTypeGetterDelegate>(wrappedType, nameof(ConstrainedToType));
        }

        /// <summary>Property added in version 4.3.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ITypeSymbol ConstrainedToType(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
        {
            return ConstrainedToTypeGetterFunc(_obj);
        }
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.8.0.0", ["Microsoft.CodeAnalysis.Operations.CommonConversion"], LanguageVersion.CSharp7_3);
        var generatedFilePath = GetGeneratedFilePath("Operations", "CommonConversionExtensions.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestBinaryOperatorKind_V3_0_0_0()
    {
        var source = @"// <auto-generated/>

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for enum Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.</summary>
    public static partial class BinaryOperatorKindEx
    {
        /// <summary>Added in version 4.3.0.0.</summary>
        public const global::Microsoft.CodeAnalysis.Operations.BinaryOperatorKind UnsignedRightShift = (global::Microsoft.CodeAnalysis.Operations.BinaryOperatorKind)25;
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.0.0.0", ["Microsoft.CodeAnalysis.Operations.BinaryOperatorKind"]);
        var generatedFilePath = GetGeneratedFilePath("Operations", "BinaryOperatorKindEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestBinaryOperatorKind_V4_4_0_0()
    {
        var test = CreateTest(AssemblyKind.Common, "4.4.0.0", ["Microsoft.CodeAnalysis.Operations.BinaryOperatorKind"]);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestGeneratedKind_V3_0_0_0()
    {
        var source = @"// <auto-generated/>

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for enum Microsoft.CodeAnalysis.GeneratedKind. Added in version 3.8.0.0.</summary>
    public enum GeneratedKindEx : global::System.Int32
    {
        /// <summary>Added in version 3.8.0.0.</summary>
        Unknown = 0,

        /// <summary>Added in version 3.8.0.0.</summary>
        NotGenerated = 1,

        /// <summary>Added in version 3.8.0.0.</summary>
        MarkedGenerated = 2,
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.0.0.0", ["Microsoft.CodeAnalysis.GeneratedKind"]);
        var generatedFilePath = GetGeneratedFilePath("GeneratedKindEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestGeneratedKind_V3_8_0_0()
    {
        var test = CreateTest(AssemblyKind.Common, "3.8.0.0", ["Microsoft.CodeAnalysis.GeneratedKind"]);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestSourceGeneratedDocument_V3_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for class Microsoft.CodeAnalysis.SourceGeneratedDocument. Added in version 3.9.0.0.</summary>
    public partial struct SourceGeneratedDocumentWrapper
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.SourceGeneratedDocument"";

        private static readonly global::System.Type? WrappedType; // NOTE: Used via reflection

        private delegate global::System.String HintNameGetterDelegate(global::Microsoft.CodeAnalysis.Document? _obj);

        private static readonly HintNameGetterDelegate HintNameGetterFunc;

        private readonly global::Microsoft.CodeAnalysis.Document? wrappedObject;

        static SourceGeneratedDocumentWrapper()
        {
            WrappedType = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.FindType(WrappedTypeName);

            HintNameGetterFunc = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.CreateInstanceGetAccessor<HintNameGetterDelegate>(WrappedType, nameof(HintName));
        }

        private SourceGeneratedDocumentWrapper(global::Microsoft.CodeAnalysis.Document? obj)
        {
            wrappedObject = obj;
        }

        /// <summary>Property added in version 3.9.0.0.</summary>
        public global::System.String HintName
        {
            get { return HintNameGetterFunc(wrappedObject); }
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, null will be stored in the wrapper instead.</summary>
        public static explicit operator SourceGeneratedDocumentWrapper(global::Microsoft.CodeAnalysis.Document? obj)
        {
            return Wrap(obj);
        }

        /// <summary>Returns the wrapped object.</summary>
        public static implicit operator global::Microsoft.CodeAnalysis.Document?(SourceGeneratedDocumentWrapper obj)
        {
            return obj.Unwrap();
        }

        /// <summary>Returns true if the specified object is compatible with this wrapper.</summary>
        public static bool Is(global::System.Object? obj)
        {
            return global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.Is(obj, WrappedType);
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, null will be stored in the wrapper instead.</summary>
        public static SourceGeneratedDocumentWrapper Wrap(global::System.Object? obj)
        {
            var obj2 = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.Wrap<global::Microsoft.CodeAnalysis.Document>(obj, WrappedType);
            return new SourceGeneratedDocumentWrapper(obj2);
        }

        /// <summary>Returns the wrapped object.</summary>
        public global::Microsoft.CodeAnalysis.Document? Unwrap()
        {
            return wrappedObject;
        }
    }
}
";

        var test = CreateTest(AssemblyKind.WorkspacesCommon, "3.0.0.0", ["Microsoft.CodeAnalysis.SourceGeneratedDocument"]);
        var generatedFilePath = GetGeneratedFilePath("SourceGeneratedDocumentWrapper.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestSourceGeneratedDocument_V4_4_0_0()
    {
        var test = CreateTest(AssemblyKind.WorkspacesCommon, "4.4.0.0", ["Microsoft.CodeAnalysis.SourceGeneratedDocument"]);
        await test.RunAsync();
    }

    // TODO: Add a test that includes removed members
    // NOTE: A property was added in 4.1.0.0 but later on removed again
    [TestMethod]
    public async Task TestParameterSyntax_V3_0_0_0()
    {
        var test = CreateTest(AssemblyKind.CSharp, "3.0.0.0", ["Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax"]);
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "SeparatedSyntaxListWrapper.g.cs", SourceText.From(SeparatedSyntaxListWrapperSource, Encoding.UTF8)));
        await test.RunAsync();
    }

    // TODO: Add a test that includes removed types
    // NOTE: The type was added in 3.1.0.0 but later on removed again
    [TestMethod]
    public async Task TestBaseExpressionTypeClauseSyntax_V3_0_0_0()
    {
        var test = CreateTest(AssemblyKind.CSharp, "3.0.0.0", ["Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionTypeClauseSyntax"]);
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "SeparatedSyntaxListWrapper.g.cs", SourceText.From(SeparatedSyntaxListWrapperSource, Encoding.UTF8)));
        await test.RunAsync();
    }

    // TODO: Add a test that includes removed members
    // NOTE: A method was added in 4.3.0.0 but later on removed again
    [TestMethod]
    public async Task TestModuleMetadata_V3_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for class Microsoft.CodeAnalysis.ModuleMetadata.</summary>
    public static partial class ModuleMetadataExtensions
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.ModuleMetadata"";

        private delegate global::Microsoft.CodeAnalysis.ModuleMetadata CreateFromMetadataDelegate0(global::System.IntPtr metadata, global::System.Int32 size, global::System.Action onDispose);

        private static readonly CreateFromMetadataDelegate0 CreateFromMetadataFunc0;

        static ModuleMetadataExtensions()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            CreateFromMetadataFunc0 = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateStaticMethodAccessor<CreateFromMetadataDelegate0>(wrappedType, ""CreateFromMetadata"", ""metadataIntPtr"", ""sizeInt32"", ""onDisposeAction"");
        }

        /// <summary>Method added in version 4.4.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ModuleMetadata CreateFromMetadata(global::System.IntPtr metadata, global::System.Int32 size, global::System.Action onDispose)
        {
            return CreateFromMetadataFunc0(metadata, size, onDispose);
        }
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.0.0.0", ["Microsoft.CodeAnalysis.ModuleMetadata"]);
        var generatedFilePath = GetGeneratedFilePath("ModuleMetadataExtensions.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    // TODO: Add a test that includes removed values
    // NOTE: Values were added in 3.1.0.0 but later on removed again
    [TestMethod]
    public async Task TestNullableAnnotation_V3_0_0_0()
    {
        var source = @"// <auto-generated/>

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for enum Microsoft.CodeAnalysis.NullableAnnotation. Added in version 3.1.0.0.</summary>
    public enum NullableAnnotationEx : global::System.Byte
    {
        /// <summary>Added in version 3.3.0.0.</summary>
        None = 0,

        /// <summary>Added in version 3.3.0.0.</summary>
        NotAnnotated = 1,

        /// <summary>Added in version 3.3.0.0.</summary>
        Annotated = 2,
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.0.0.0", ["Microsoft.CodeAnalysis.NullableAnnotation"]);
        var generatedFilePath = GetGeneratedFilePath("NullableAnnotationEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    protected virtual string GetGeneratedFilePath(params string[] parts)
    {
        var result = $"Microsoft.CodeAnalysis.{string.Join(".", parts)}";
        return result;
    }

    private static CSharpSourceGeneratorTest<LightupGenerator, DefaultVerifier> CreateTest(
        AssemblyKind? assemblyKind,
        string? baselineVersion,
        List<string> typesToInclude,
        LanguageVersion? languageVersion = null,
        bool? useFoldersInFilePaths = null,
        bool shouldGeneratedFiles = true)
    {
        var na = (languageVersion == null || languageVersion >= LanguageVersion.CSharp8) ? "?" : "";
        useFoldersInFilePaths ??= Helpers.RoslynSupportsFoldersInGeneratedFilePaths;

        var lightupHelperSource = $@"
namespace CodeAnalysis.Lightup.Runtime
{{
    using System;
    using System.Reflection;
    
    public class LightupHelper
    {{
        public static Type{na} FindType(Assembly assembly, string wrappedTypeName)
            => throw new Exception();
        
        public static bool Is(object{na} obj, Type{na} wrappedType)
            => throw new Exception();
        
        public static TObject{na} Wrap<TObject>(object{na} obj, Type{na} wrappedType)
            where TObject : class
            => throw new Exception();        
        
        public static TDelegate CreateInstanceGetAccessor<TDelegate>(Type{na} wrappedType, string memberName)
            where TDelegate : Delegate
            => throw new Exception();
        
        public static TDelegate CreateStaticMethodAccessor<TDelegate>(Type{na} wrappedType, string memberName, params string[] paramTags)
            where TDelegate : Delegate
            => throw new Exception();
        
        public static TDelegate CreateInstanceMethodAccessor<TDelegate>(Type{na} wrappedType, string memberName, params string[] paramTags)
            where TDelegate : Delegate
            => throw new Exception();
    }}
}}";

        var specificLightupHelperSource = $@"
// <auto-generated/>
{(languageVersion == null || languageVersion >= LanguageVersion.CSharp8 ? "#nullable enable" : "")}

namespace Microsoft.CodeAnalysis.Lightup
{{
    internal class {assemblyKind}LightupHelper : global::CodeAnalysis.Lightup.Runtime.LightupHelper
    {{
        private static readonly global::System.Reflection.Assembly Assembly = typeof(global::{ExampleTypeNames[assemblyKind ?? AssemblyKind.Common]}).Assembly;

        public static global::System.Type{na} FindType(string wrappedTypeName)
        {{
            return FindType(Assembly, wrappedTypeName);
        }}
    }}
}}
";

        var test = new CSharpSourceGeneratorTest<LightupGenerator, DefaultVerifier>()
        {
            TestState =
            {
                Sources = { lightupHelperSource },
            },
            ReferenceAssemblies = CreateReferenceAssemblies(),
        };

        if (shouldGeneratedFiles)
        {
            test.TestState.GeneratedSources.Add((typeof(LightupGenerator), $"{assemblyKind}LightupHelper.g.cs", SourceText.From(specificLightupHelperSource, Encoding.UTF8)));
        }

        test.SolutionTransforms.Add((solution, projectId) =>
        {
            if (languageVersion != null)
            {
                var project = solution.GetProject(projectId);
                var parseOptions = ((CSharpParseOptions)project!.ParseOptions!).WithLanguageVersion(languageVersion.Value);
                solution = solution.WithProjectParseOptions(projectId, parseOptions);
            }

            return solution;
        });

        var configFileContent = $@"{{
	{(assemblyKind != null ? $@"""assemblies"": [ ""{assemblyKind}"" ]," : "")}
	{(baselineVersion != null ? $@"""baselineVersion"": ""{baselineVersion}""," : "")}
    ""includeTypes"": [ {string.Join(", ", typesToInclude.Select(x => $@"""{x}"""))} ],
    ""useFoldersInFilePaths"": {(useFoldersInFilePaths.Value ? "true" : "false")}
}}";
        test.TestState.AdditionalFiles.Add(("CodeAnalysis.Lightup.json", configFileContent));

        return test;
    }

    private static ReferenceAssemblies CreateReferenceAssemblies()
    {
        return ReferenceAssemblies.Net.Net80
            .AddPackages([new PackageIdentity("Microsoft.CodeAnalysis", "3.0.0")]);
    }
}
