// Copyright © Björn Hellander 2024
// Licensed under the MIT License. See LICENSE.txt in the repository root for license information.

namespace CodeAnalysis.Lightup.Test.Generator.V4_0_1;

[TestClass]
public class LightupGeneratorTests
{
    private const string SeparatedSyntaxListWrapperSource = @"
// <auto-generated/>
#pragma warning disable CS1591
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    public struct SeparatedSyntaxListWrapper<TNode> : global::System.Collections.Generic.IEnumerable<TNode>
        where TNode : struct
    {
        private static readonly global::System.Type? WrappedType;

        private delegate int CountDelegate(object obj);
        private delegate int SeparatorCountDelegate(object obj);
        private delegate global::Microsoft.CodeAnalysis.Text.TextSpan FullSpanDelegate(object obj);
        private delegate global::Microsoft.CodeAnalysis.Text.TextSpan SpanDelegate(object obj);
        private delegate TNode IndexerDelegate(object obj, int index);
        private delegate global::Microsoft.CodeAnalysis.SyntaxToken GetSeparatorDelegate(object obj, int index);
        private delegate global::System.Collections.Generic.IEnumerable<global::Microsoft.CodeAnalysis.SyntaxToken> GetSeparatorsDelegate(object obj);
        private delegate string ToStringDelegate(object obj);
        private delegate string ToFullStringDelegate(object obj);
        private delegate TNode FirstDelegate(object obj);
        private delegate TNode? FirstOrDefaultDelegate(object obj);
        private delegate TNode LastDelegate(object obj);
        private delegate TNode? LastOrDefaultDelegate(object obj);
        private delegate bool ContainsDelegate(object obj, TNode node);
        private delegate int IndexOfNodeDelegate(object obj, TNode node);
        private delegate int IndexOfPredicateDelegate(object obj, global::System.Func<TNode, bool> predicate);
        private delegate int LastIndexOfNodeDelegate(object obj, TNode node);
        private delegate int LastIndexOfPredicateDelegate(object obj, global::System.Func<TNode, bool> predicate);
        private delegate bool AnyDelegate(object obj);
        private delegate SyntaxNodeOrTokenList GetWithSeparatorsDelegate(object obj);
        private delegate SeparatedSyntaxListWrapper<TNode> AddDelegate(object obj, TNode node);
        private delegate SeparatedSyntaxListWrapper<TNode> AddRangeDelegate(object obj, global::System.Collections.Generic.IEnumerable<TNode> arg1);
        private delegate SeparatedSyntaxListWrapper<TNode> InsertDelegate(object obj, int index, TNode node);
        private delegate SeparatedSyntaxListWrapper<TNode> InsertRangeDelegate(object obj, int index, global::System.Collections.Generic.IEnumerable<TNode> arg1);
        private delegate SeparatedSyntaxListWrapper<TNode> RemoveAtDelegate(object obj, int index);
        private delegate SeparatedSyntaxListWrapper<TNode> RemoveDelegate(object obj, TNode node);
        private delegate SeparatedSyntaxListWrapper<TNode> ReplaceDelegate(object obj, TNode nodeInList, TNode newNode);
        private delegate SeparatedSyntaxListWrapper<TNode> ReplaceRangeDelegate(object obj, TNode nodeInList, global::System.Collections.Generic.IEnumerable<TNode> newNodes);
        private delegate SeparatedSyntaxListWrapper<TNode> ReplaceSeparatorDelegate(object obj, global::Microsoft.CodeAnalysis.SyntaxToken separatorToken, global::Microsoft.CodeAnalysis.SyntaxToken newSeparator);

        private static readonly CountDelegate CountAccessor;
        private static readonly SeparatorCountDelegate SeparatorCountAccessor;
        private static readonly FullSpanDelegate FullSpanAccessor;
        private static readonly SpanDelegate SpanAccessor;
        private static readonly IndexerDelegate IndexerAccessor;
        private static readonly GetSeparatorDelegate GetSeparatorAccessor;
        private static readonly GetSeparatorsDelegate GetSeparatorsAccessor;
        private static readonly ToStringDelegate ToStringAccessor;
        private static readonly ToFullStringDelegate ToFullStringAccessor;
        private static readonly FirstDelegate FirstAccessor;
        private static readonly FirstOrDefaultDelegate FirstOrDefaultAccessor;
        private static readonly LastDelegate LastAccessor;
        private static readonly LastOrDefaultDelegate LastOrDefaultAccessor;
        private static readonly ContainsDelegate ContainsAccessor;
        private static readonly IndexOfNodeDelegate IndexOfNodeAccessor;
        private static readonly IndexOfPredicateDelegate IndexOfPredicateAccessor;
        private static readonly LastIndexOfNodeDelegate LastIndexOfNodeAccessor;
        private static readonly LastIndexOfPredicateDelegate LastIndexOfPredicateAccessor;
        private static readonly AnyDelegate AnyAccessor;
        private static readonly GetWithSeparatorsDelegate GetWithSeparatorsAccessor;
        private static readonly AddDelegate AddAccessor;
        private static readonly AddRangeDelegate AddRangeAccessor;
        private static readonly InsertDelegate InsertAccessor;
        private static readonly InsertRangeDelegate InsertRangeAccessor;
        private static readonly RemoveAtDelegate RemoveAtAccessor;
        private static readonly RemoveDelegate RemoveAccessor;
        private static readonly ReplaceDelegate ReplaceAccessor;
        private static readonly ReplaceRangeDelegate ReplaceRangeAccessor;
        private static readonly ReplaceSeparatorDelegate ReplaceSeparatorAccessor;

        private readonly object wrappedObject;

        static SeparatedSyntaxListWrapper()
        {
            var wrapperNodeType = typeof(TNode);
            var wrappedNodeTypeField = wrapperNodeType.GetField(""WrappedType"", global::System.Reflection.BindingFlags.Static | global::System.Reflection.BindingFlags.NonPublic);
            var wrappedNodeType = (global::System.Type)wrappedNodeTypeField.GetValue(null);
            var wrappedNodeTypeName = wrappedNodeType?.Name;
            WrappedType = wrappedNodeType != null ? typeof(SeparatedSyntaxList<>).MakeGenericType(wrappedNodeType) : null;

            CountAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<CountDelegate>(WrappedType, nameof(Count));
            SeparatorCountAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<SeparatorCountDelegate>(WrappedType, nameof(SeparatorCount));
            FullSpanAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<FullSpanDelegate>(WrappedType, nameof(FullSpan));
            SpanAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<SpanDelegate>(WrappedType, nameof(Span));
            IndexerAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<IndexerDelegate>(WrappedType, ""get_Item"", ""indexInt32"");
            GetSeparatorAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<GetSeparatorDelegate>(WrappedType, nameof(GetSeparator), ""indexInt32"");
            GetSeparatorsAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<GetSeparatorsDelegate>(WrappedType, nameof(GetSeparators));
            ToStringAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<ToStringDelegate>(WrappedType, nameof(ToString));
            ToFullStringAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<ToFullStringDelegate>(WrappedType, nameof(ToFullString));
            FirstAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<FirstDelegate>(WrappedType, nameof(First));
            FirstOrDefaultAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<FirstOrDefaultDelegate>(WrappedType, nameof(FirstOrDefault));
            LastAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<LastDelegate>(WrappedType, nameof(Last));
            LastOrDefaultAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<LastOrDefaultDelegate>(WrappedType, nameof(LastOrDefault));
            ContainsAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<ContainsDelegate>(WrappedType, nameof(Contains), ""node"" + wrappedNodeTypeName);
            IndexOfNodeAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<IndexOfNodeDelegate>(WrappedType, nameof(IndexOf), ""node"" + wrappedNodeTypeName);
            IndexOfPredicateAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<IndexOfPredicateDelegate>(WrappedType, nameof(IndexOf), ""predicateFunc`2"");
            LastIndexOfNodeAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<LastIndexOfNodeDelegate>(WrappedType, nameof(LastIndexOf), ""node"" + wrappedNodeTypeName);
            LastIndexOfPredicateAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<LastIndexOfPredicateDelegate>(WrappedType, nameof(LastIndexOf), ""predicateFunc`2"");
            AnyAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<AnyDelegate>(WrappedType, nameof(Any));
            GetWithSeparatorsAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<GetWithSeparatorsDelegate>(WrappedType, nameof(GetWithSeparators));
            AddAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<AddDelegate>(WrappedType, nameof(Add), ""node"" + wrappedNodeTypeName);
            AddRangeAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<AddRangeDelegate>(WrappedType, nameof(AddRange), ""nodesIEnumerable`1"");
            InsertAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<InsertDelegate>(WrappedType, nameof(Insert), ""indexInt32"", ""node"" + wrappedNodeTypeName);
            InsertRangeAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<InsertRangeDelegate>(WrappedType, nameof(InsertRange), ""indexInt32"", ""nodesIEnumerable`1"");
            RemoveAtAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<RemoveAtDelegate>(WrappedType, nameof(RemoveAt), ""indexInt32"");
            RemoveAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<RemoveDelegate>(WrappedType, nameof(Remove), ""node"" + wrappedNodeTypeName);
            ReplaceAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<ReplaceDelegate>(WrappedType, nameof(Replace), ""nodeInList"" + wrappedNodeTypeName, ""newNode"" + wrappedNodeTypeName);
            ReplaceRangeAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<ReplaceRangeDelegate>(WrappedType, nameof(ReplaceRange), ""nodeInList"" + wrappedNodeTypeName, ""newNodesIEnumerable`1"");
            ReplaceSeparatorAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<ReplaceSeparatorDelegate>(WrappedType, nameof(ReplaceSeparator), ""separatorTokenSyntaxToken"", ""newSeparatorSyntaxToken"");
        }

        private SeparatedSyntaxListWrapper(object obj)
        {
            wrappedObject = obj;
        }

        public int Count
        {
            get { return CountAccessor(wrappedObject); }
        }

        public int SeparatorCount
        {
            get { return SeparatorCountAccessor(wrappedObject); }
        }

        public global::Microsoft.CodeAnalysis.Text.TextSpan FullSpan
        {
            get { return FullSpanAccessor(wrappedObject); }
        }

        public global::Microsoft.CodeAnalysis.Text.TextSpan Span
        {
            get { return SpanAccessor(wrappedObject); }
        }

        public TNode this[int index]
        {
             get { return IndexerAccessor(wrappedObject, index); }
        }

        //public static implicit operator SeparatedSyntaxListWrapper<SyntaxNode>(SeparatedSyntaxListWrapper<TNode> nodes)
        //{
        //     throw new global::System.NotImplementedException();
        //}

        //public static implicit operator SeparatedSyntaxListWrapper<TNode>(SeparatedSyntaxListWrapper<SyntaxNode> nodes)
        //{
        //     throw new global::System.NotImplementedException();
        //}

        public static bool Is(object? obj)
        {
            return global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.Is(obj, WrappedType);
        }

        public static SeparatedSyntaxListWrapper<TNode> Wrap(object obj)
        {
            var obj2 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.Wrap<object>(obj, WrappedType);
            return new SeparatedSyntaxListWrapper<TNode>(obj2);
        }

        public object Unwrap()
        {
             return wrappedObject;
        }

        public global::System.Collections.Generic.IEnumerator<TNode> GetEnumerator()
        {
            return new Enumerator(this);
        }

        global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator()
        {
            return new Enumerator(this);
        }

        public global::Microsoft.CodeAnalysis.SyntaxToken GetSeparator(int index)
        {
             return GetSeparatorAccessor(wrappedObject, index);
        }

        public global::System.Collections.Generic.IEnumerable<global::Microsoft.CodeAnalysis.SyntaxToken> GetSeparators()
        {
             return GetSeparatorsAccessor(wrappedObject);
        }

        public override string ToString()
        {
             return ToStringAccessor(wrappedObject);
        }

        public string ToFullString()
        {
             return ToFullStringAccessor(wrappedObject);
        }

        public TNode First()
        {
             return FirstAccessor(wrappedObject);
        }

        public TNode? FirstOrDefault()
        {
             return FirstOrDefaultAccessor(wrappedObject);
        }

        public TNode Last()
        {
             return LastAccessor(wrappedObject);
        }

        public TNode? LastOrDefault()
        {
             return LastOrDefaultAccessor(wrappedObject);
        }

        public bool Contains(TNode node)
        {
             return ContainsAccessor(wrappedObject, node);
        }

        public int IndexOf(TNode node)
        {
            return IndexOfNodeAccessor(wrappedObject, node);
        }

        public int IndexOf(global::System.Func<TNode, bool> predicate)
        {
            return IndexOfPredicateAccessor(wrappedObject, predicate);
        }

        public int LastIndexOf(TNode node)
        {
            return LastIndexOfNodeAccessor(wrappedObject, node);
        }

        public int LastIndexOf(global::System.Func<TNode, bool> predicate)
        {
            return LastIndexOfPredicateAccessor(wrappedObject, predicate);
        }

        public bool Any()
        {
            return AnyAccessor(wrappedObject);
        }

        public SyntaxNodeOrTokenList GetWithSeparators()
        {
             return GetWithSeparatorsAccessor(wrappedObject);
        }

        public SeparatedSyntaxListWrapper<TNode> Add(TNode node)
        {
             return AddAccessor(wrappedObject, node);
        }

        public SeparatedSyntaxListWrapper<TNode> AddRange(global::System.Collections.Generic.IEnumerable<TNode> nodes)
        {
             return AddRangeAccessor(wrappedObject, nodes);
        }

        public SeparatedSyntaxListWrapper<TNode> Insert(int index, TNode node)
        {
             return InsertAccessor(wrappedObject, index, node);
        }

        public SeparatedSyntaxListWrapper<TNode> InsertRange(int index, global::System.Collections.Generic.IEnumerable<TNode> nodes)
        {
             return InsertRangeAccessor(wrappedObject, index, nodes);
        }

        public SeparatedSyntaxListWrapper<TNode> RemoveAt(int index)
        {
             return RemoveAtAccessor(wrappedObject, index);
        }

        public SeparatedSyntaxListWrapper<TNode> Remove(TNode node)
        {
             return RemoveAccessor(wrappedObject, node);
        }

        public SeparatedSyntaxListWrapper<TNode> Replace(TNode nodeInList, TNode newNode)
        {
             return ReplaceAccessor(wrappedObject, nodeInList, newNode);
        }

        public SeparatedSyntaxListWrapper<TNode> ReplaceRange(TNode nodeInList, global::System.Collections.Generic.IEnumerable<TNode> newNodes)
        {
             return ReplaceRangeAccessor(wrappedObject, nodeInList, newNodes);
        }

        public SeparatedSyntaxListWrapper<TNode> ReplaceSeparator(global::Microsoft.CodeAnalysis.SyntaxToken separatorToken, global::Microsoft.CodeAnalysis.SyntaxToken newSeparator)
        {
             return ReplaceSeparatorAccessor(wrappedObject, separatorToken, newSeparator);
        }

        private class Enumerator : global::System.Collections.Generic.IEnumerator<TNode>
        {
            private readonly SeparatedSyntaxListWrapper<TNode> wrapper;
            private int i;

            public Enumerator(SeparatedSyntaxListWrapper<TNode> wrapper)
            {
                this.wrapper = wrapper;
                i = -1;
            }

            public TNode Current => wrapper[i];

            object global::System.Collections.IEnumerator.Current => wrapper[i];

            public bool MoveNext()
            {
                var j = i + 1;
                if (j < wrapper.Count)
                {
                    i = j;
                    return true;
                }

                return false;
            }

            public void Reset()
            {
                i = -1;
            }

            public void Dispose()
            {
            }
        }
    }
}
";

    private static readonly Dictionary<AssemblyKind, string> AssemblyKindStrings = new()
    {
        [AssemblyKind.Common] = "Microsoft.CodeAnalysis.Common",
        [AssemblyKind.CSharp] = "Microsoft.CodeAnalysis.CSharp",
        [AssemblyKind.WorkspacesCommon] = "Microsoft.CodeAnalysis.Workspaces.Common",
        [AssemblyKind.CSharpWorkspaces] = "Microsoft.CodeAnalysis.CSharp.Workspaces",
    };

    private static readonly Dictionary<AssemblyKind, string> ExampleTypeNames = new()
    {
        [AssemblyKind.Common] = "Microsoft.CodeAnalysis.IOperation",
        [AssemblyKind.CSharp] = "Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax",
        [AssemblyKind.WorkspacesCommon] = "Microsoft.CodeAnalysis.WorkspaceChangeKind",
    };

    protected virtual bool SupportsFoldersInFilePaths => false;

    [TestMethod]
    public async Task TestNoAssemblyKindInConfigurationFile()
    {
        var test = CreateTest(null, "3.3.0.0", [""], shouldGeneratedFiles: false);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestNoBaselineVersionInConfigurationFile()
    {
        var test = CreateTest(AssemblyKind.Common, null, [""], shouldGeneratedFiles: false);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestUnsupportedFoldersInFilePaths()
    {
        if (SupportsFoldersInFilePaths)
        {
            return;
        }

        var test = CreateTest(AssemblyKind.Common, "3.3.0.0", [""], useFoldersInFilePaths: true, shouldGeneratedFiles: false);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestSeparatedSyntaxListWrapper()
    {
        var source = SeparatedSyntaxListWrapperSource;

        var test = CreateTest(AssemblyKind.CSharp, "3.0.0.0", [""]);
        var generatedFilePath = "SeparatedSyntaxListWrapper.g.cs";
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestCommonConversion_V3_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for struct Microsoft.CodeAnalysis.Operations.CommonConversion.</summary>
    public static partial class CommonConversionEx
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.Operations.CommonConversion"";

        private delegate global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToTypeGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj);
        private delegate global::System.Boolean IsNullableGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj);

        private static readonly ConstrainedToTypeGetterDelegate ConstrainedToTypeGetterFunc;
        private static readonly IsNullableGetterDelegate IsNullableGetterFunc;

        static CommonConversionEx()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            ConstrainedToTypeGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<ConstrainedToTypeGetterDelegate>(wrappedType, nameof(ConstrainedToType));
            IsNullableGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<IsNullableGetterDelegate>(wrappedType, nameof(IsNullable));
        }

        /// <summary>Property added in version 4.3.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToType(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
        {
            return ConstrainedToTypeGetterFunc(_obj);
        }

        /// <summary>Property added in version 3.7.0.0.</summary>
        public static global::System.Boolean IsNullable(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
        {
            return IsNullableGetterFunc(_obj);
        }
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.3.0.0", ["Microsoft.CodeAnalysis.Operations.CommonConversion"]);
        var generatedFilePath = GetGeneratedFilePath("Operations", "CommonConversionEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestCommonConversion_V3_8_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for struct Microsoft.CodeAnalysis.Operations.CommonConversion.</summary>
    public static partial class CommonConversionEx
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.Operations.CommonConversion"";

        private delegate global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToTypeGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj);

        private static readonly ConstrainedToTypeGetterDelegate ConstrainedToTypeGetterFunc;

        static CommonConversionEx()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            ConstrainedToTypeGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<ConstrainedToTypeGetterDelegate>(wrappedType, nameof(ConstrainedToType));
        }

        /// <summary>Property added in version 4.3.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToType(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
        {
            return ConstrainedToTypeGetterFunc(_obj);
        }
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.8.0.0", ["Microsoft.CodeAnalysis.Operations.CommonConversion"]);
        var generatedFilePath = GetGeneratedFilePath("Operations", "CommonConversionEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestCommonConversion_V3_8_0_0_CSharp7_3()
    {
        var source = @"// <auto-generated/>


namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for struct Microsoft.CodeAnalysis.Operations.CommonConversion.</summary>
    public static partial class CommonConversionEx
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.Operations.CommonConversion"";

        private delegate global::Microsoft.CodeAnalysis.ITypeSymbol ConstrainedToTypeGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj);

        private static readonly ConstrainedToTypeGetterDelegate ConstrainedToTypeGetterFunc;

        static CommonConversionEx()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            ConstrainedToTypeGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<ConstrainedToTypeGetterDelegate>(wrappedType, nameof(ConstrainedToType));
        }

        /// <summary>Property added in version 4.3.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ITypeSymbol ConstrainedToType(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
        {
            return ConstrainedToTypeGetterFunc(_obj);
        }
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.8.0.0", ["Microsoft.CodeAnalysis.Operations.CommonConversion"], LanguageVersion.CSharp7_3);
        var generatedFilePath = GetGeneratedFilePath("Operations", "CommonConversionEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestBinaryOperatorKind_V3_0_0_0()
    {
        var source = @"// <auto-generated/>

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for enum Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.</summary>
    public static partial class BinaryOperatorKindEx
    {
        /// <summary>Added in version 4.3.0.0.</summary>
        public const global::Microsoft.CodeAnalysis.Operations.BinaryOperatorKind UnsignedRightShift = (global::Microsoft.CodeAnalysis.Operations.BinaryOperatorKind)25;
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.0.0.0", ["Microsoft.CodeAnalysis.Operations.BinaryOperatorKind"]);
        var generatedFilePath = GetGeneratedFilePath("Operations", "BinaryOperatorKindEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestBinaryOperatorKind_V4_4_0_0()
    {
        var test = CreateTest(AssemblyKind.Common, "4.4.0.0", ["Microsoft.CodeAnalysis.Operations.BinaryOperatorKind"]);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestGeneratedKind_V3_0_0_0()
    {
        var source = @"// <auto-generated/>

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for enum Microsoft.CodeAnalysis.GeneratedKind. Added in version 3.8.0.0.</summary>
    public enum GeneratedKindEx : global::System.Int32
    {
        /// <summary>Added in version 3.8.0.0.</summary>
        Unknown = 0,

        /// <summary>Added in version 3.8.0.0.</summary>
        NotGenerated = 1,

        /// <summary>Added in version 3.8.0.0.</summary>
        MarkedGenerated = 2,
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.0.0.0", ["Microsoft.CodeAnalysis.GeneratedKind"]);
        var generatedFilePath = GetGeneratedFilePath("GeneratedKindEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestGeneratedKind_V3_8_0_0()
    {
        var test = CreateTest(AssemblyKind.Common, "3.8.0.0", ["Microsoft.CodeAnalysis.GeneratedKind"]);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestSourceGeneratedDocument_V3_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for class Microsoft.CodeAnalysis.SourceGeneratedDocument. Added in version 3.9.0.0.</summary>
    public partial struct SourceGeneratedDocumentWrapper
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.SourceGeneratedDocument"";

        private static readonly global::System.Type? WrappedType;

        private delegate global::System.String HintNameGetterDelegate(global::Microsoft.CodeAnalysis.Document _obj);

        private static readonly HintNameGetterDelegate HintNameGetterFunc;

        private readonly global::Microsoft.CodeAnalysis.Document wrappedObject;

        static SourceGeneratedDocumentWrapper()
        {
            WrappedType = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.FindType(WrappedTypeName);

            HintNameGetterFunc = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.CreateInstanceGetAccessor<HintNameGetterDelegate>(WrappedType, nameof(HintName));
        }

        private SourceGeneratedDocumentWrapper(global::Microsoft.CodeAnalysis.Document obj)
        {
            wrappedObject = obj;
        }

        /// <summary>Property added in version 3.9.0.0.</summary>
        public global::System.String HintName
        {
            get { return HintNameGetterFunc(wrappedObject); }
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, an exception will be thrown.</summary>
        public static explicit operator SourceGeneratedDocumentWrapper(global::Microsoft.CodeAnalysis.Document obj)
        {
            return Wrap(obj);
        }

        /// <summary>Returns the wrapped object.</summary>
        public static implicit operator global::Microsoft.CodeAnalysis.Document(SourceGeneratedDocumentWrapper obj)
        {
            return obj.Unwrap();
        }

        /// <summary>Returns true if the specified object is compatible with this wrapper.</summary>
        public static bool Is(global::Microsoft.CodeAnalysis.Document? obj)
        {
            return global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.Is(obj, WrappedType);
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, an exception will be thrown.</summary>
        public static SourceGeneratedDocumentWrapper Wrap(global::Microsoft.CodeAnalysis.Document obj)
        {
            var obj2 = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.Wrap<global::Microsoft.CodeAnalysis.Document>(obj, WrappedType);
            return new SourceGeneratedDocumentWrapper(obj2);
        }

        /// <summary>Returns the wrapped object.</summary>
        public global::Microsoft.CodeAnalysis.Document Unwrap()
        {
            return wrappedObject;
        }
    }
}
";

        var test = CreateTest(AssemblyKind.WorkspacesCommon, "3.0.0.0", ["Microsoft.CodeAnalysis.SourceGeneratedDocument"]);
        var generatedFilePath = GetGeneratedFilePath("SourceGeneratedDocumentWrapper.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestSourceGeneratedDocument_V4_4_0_0()
    {
        var test = CreateTest(AssemblyKind.WorkspacesCommon, "4.4.0.0", ["Microsoft.CodeAnalysis.SourceGeneratedDocument"]);
        await test.RunAsync();
    }

    // TODO: Add a test that includes removed members
    // NOTE: A property was added in 4.1.0.0 but later on removed again
    [TestMethod]
    public async Task TestParameterSyntax_V3_0_0_0()
    {
        var test = CreateTest(AssemblyKind.CSharp, "3.0.0.0", ["Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax"]);
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "SeparatedSyntaxListWrapper.g.cs", SourceText.From(SeparatedSyntaxListWrapperSource, Encoding.UTF8)));
        await test.RunAsync();
    }

    // TODO: Add a test that includes removed types
    // NOTE: The type was added in 3.1.0.0 but later on removed again
    [TestMethod]
    public async Task TestBaseExpressionTypeClauseSyntax_V3_0_0_0()
    {
        var test = CreateTest(AssemblyKind.CSharp, "3.0.0.0", ["Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionTypeClauseSyntax"]);
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "SeparatedSyntaxListWrapper.g.cs", SourceText.From(SeparatedSyntaxListWrapperSource, Encoding.UTF8)));
        await test.RunAsync();
    }

    // TODO: Add a test that includes removed members
    // NOTE: A method was added in 4.3.0.0 but later on removed again
    [TestMethod]
    public async Task TestModuleMetadata_V3_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for class Microsoft.CodeAnalysis.ModuleMetadata.</summary>
    public static partial class ModuleMetadataEx
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.ModuleMetadata"";

        private delegate global::Microsoft.CodeAnalysis.ModuleMetadata CreateFromMetadataDelegate0(global::System.IntPtr metadata, global::System.Int32 size, global::System.Action onDispose);

        private static readonly CreateFromMetadataDelegate0 CreateFromMetadataFunc0;

        static ModuleMetadataEx()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            CreateFromMetadataFunc0 = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateStaticMethodAccessor<CreateFromMetadataDelegate0>(wrappedType, ""CreateFromMetadata"", ""metadataIntPtr"", ""sizeInt32"", ""onDisposeAction"");
        }

        /// <summary>Method added in version 4.4.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ModuleMetadata CreateFromMetadata(global::System.IntPtr metadata, global::System.Int32 size, global::System.Action onDispose)
        {
            return CreateFromMetadataFunc0(metadata, size, onDispose);
        }
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.0.0.0", ["Microsoft.CodeAnalysis.ModuleMetadata"]);
        var generatedFilePath = GetGeneratedFilePath("ModuleMetadataEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    // TODO: Add a test that includes removed values
    // NOTE: Values were added in 3.1.0.0 but later on removed again
    [TestMethod]
    public async Task TestNullableAnnotation_V3_0_0_0()
    {
        var source = @"// <auto-generated/>

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for enum Microsoft.CodeAnalysis.NullableAnnotation. Added in version 3.1.0.0.</summary>
    public enum NullableAnnotationEx : global::System.Byte
    {
        /// <summary>Added in version 3.3.0.0.</summary>
        None = 0,

        /// <summary>Added in version 3.3.0.0.</summary>
        NotAnnotated = 1,

        /// <summary>Added in version 3.3.0.0.</summary>
        Annotated = 2,
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.0.0.0", ["Microsoft.CodeAnalysis.NullableAnnotation"]);
        var generatedFilePath = GetGeneratedFilePath("NullableAnnotationEx.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    // TODO: Add a test that includes removed values
    // NOTE: Values were added in 3.1.0.0 but later on removed again
    [TestMethod]
    public async Task TestIConstructorBodyOperation_V2_6_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for interface Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation. Added in version 2.8.0.0.</summary>
    public partial struct IConstructorBodyOperationWrapper
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation"";

        private static readonly global::System.Type? WrappedType;

        private delegate global::Microsoft.CodeAnalysis.IOperation? InitializerGetterDelegate(global::System.Object _obj);
        private delegate global::System.Collections.Immutable.ImmutableArray<global::Microsoft.CodeAnalysis.ILocalSymbol> LocalsGetterDelegate(global::System.Object _obj);

        private static readonly InitializerGetterDelegate InitializerGetterFunc;
        private static readonly LocalsGetterDelegate LocalsGetterFunc;

        private readonly global::System.Object wrappedObject;

        static IConstructorBodyOperationWrapper()
        {
            WrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            InitializerGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<InitializerGetterDelegate>(WrappedType, nameof(Initializer));
            LocalsGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<LocalsGetterDelegate>(WrappedType, nameof(Locals));
        }

        private IConstructorBodyOperationWrapper(global::System.Object obj)
        {
            wrappedObject = obj;
        }

        /// <summary>Property added in version 2.8.0.0.</summary>
        public global::Microsoft.CodeAnalysis.IOperation? Initializer
        {
            get { return InitializerGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 2.8.0.0.</summary>
        public global::System.Collections.Immutable.ImmutableArray<global::Microsoft.CodeAnalysis.ILocalSymbol> Locals
        {
            get { return LocalsGetterFunc(wrappedObject); }
        }

        /// <summary>Returns true if the specified object is compatible with this wrapper.</summary>
        public static bool Is(global::System.Object? obj)
        {
            return global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.Is(obj, WrappedType);
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, an exception will be thrown.</summary>
        public static IConstructorBodyOperationWrapper Wrap(global::System.Object obj)
        {
            var obj2 = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.Wrap<global::System.Object>(obj, WrappedType);
            return new IConstructorBodyOperationWrapper(obj2);
        }

        /// <summary>Returns the wrapped object.</summary>
        public global::System.Object Unwrap()
        {
            return wrappedObject;
        }
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "2.6.0.0", ["Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation"]);
        var generatedFilePath = GetGeneratedFilePath("Operations", "IConstructorBodyOperationWrapper.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    // NOTE: Added in 2.0.0.0, so nothing should be generated
    [TestMethod]
    public async Task TestDocumentActiveContextChangedEventArgs_V3_0_0_0()
    {
        var test = CreateTest(AssemblyKind.WorkspacesCommon, "3.0.0.0", ["Microsoft.CodeAnalysis.DocumentActiveContextChangedEventArgs"]);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestDocumentActiveContextChangedEventArgs_V0_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for class Microsoft.CodeAnalysis.DocumentActiveContextChangedEventArgs. Added in version 2.0.0.0.</summary>
    public partial struct DocumentActiveContextChangedEventArgsWrapper
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.DocumentActiveContextChangedEventArgs"";

        private static readonly global::System.Type? WrappedType;

        private delegate DocumentActiveContextChangedEventArgsWrapper ConstructorDelegate0(global::Microsoft.CodeAnalysis.Solution solution, global::Microsoft.CodeAnalysis.Text.SourceTextContainer sourceTextContainer, global::Microsoft.CodeAnalysis.DocumentId oldActiveContextDocumentId, global::Microsoft.CodeAnalysis.DocumentId newActiveContextDocumentId);

        private delegate global::Microsoft.CodeAnalysis.DocumentId NewActiveContextDocumentIdGetterDelegate(global::System.EventArgs _obj);
        private delegate global::Microsoft.CodeAnalysis.DocumentId OldActiveContextDocumentIdGetterDelegate(global::System.EventArgs _obj);
        private delegate global::Microsoft.CodeAnalysis.Solution SolutionGetterDelegate(global::System.EventArgs _obj);
        private delegate global::Microsoft.CodeAnalysis.Text.SourceTextContainer SourceTextContainerGetterDelegate(global::System.EventArgs _obj);

        private static readonly ConstructorDelegate0 ConstructorFunc0;

        private static readonly NewActiveContextDocumentIdGetterDelegate NewActiveContextDocumentIdGetterFunc;
        private static readonly OldActiveContextDocumentIdGetterDelegate OldActiveContextDocumentIdGetterFunc;
        private static readonly SolutionGetterDelegate SolutionGetterFunc;
        private static readonly SourceTextContainerGetterDelegate SourceTextContainerGetterFunc;

        private readonly global::System.EventArgs wrappedObject;

        static DocumentActiveContextChangedEventArgsWrapper()
        {
            WrappedType = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.FindType(WrappedTypeName);

            ConstructorFunc0 = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.CreateInstanceConstructorAccessor<ConstructorDelegate0>(WrappedType, ""solutionSolution"", ""sourceTextContainerSourceTextContainer"", ""oldActiveContextDocumentIdDocumentId"", ""newActiveContextDocumentIdDocumentId"");

            NewActiveContextDocumentIdGetterFunc = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.CreateInstanceGetAccessor<NewActiveContextDocumentIdGetterDelegate>(WrappedType, nameof(NewActiveContextDocumentId));
            OldActiveContextDocumentIdGetterFunc = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.CreateInstanceGetAccessor<OldActiveContextDocumentIdGetterDelegate>(WrappedType, nameof(OldActiveContextDocumentId));
            SolutionGetterFunc = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.CreateInstanceGetAccessor<SolutionGetterDelegate>(WrappedType, nameof(Solution));
            SourceTextContainerGetterFunc = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.CreateInstanceGetAccessor<SourceTextContainerGetterDelegate>(WrappedType, nameof(SourceTextContainer));
        }

        private DocumentActiveContextChangedEventArgsWrapper(global::System.EventArgs obj)
        {
            wrappedObject = obj;
        }

        /// <summary>Constructor added in version 2.0.0.0.</summary>
        public static DocumentActiveContextChangedEventArgsWrapper Create(global::Microsoft.CodeAnalysis.Solution solution, global::Microsoft.CodeAnalysis.Text.SourceTextContainer sourceTextContainer, global::Microsoft.CodeAnalysis.DocumentId oldActiveContextDocumentId, global::Microsoft.CodeAnalysis.DocumentId newActiveContextDocumentId)
        {
            return ConstructorFunc0(solution, sourceTextContainer, oldActiveContextDocumentId, newActiveContextDocumentId);
        }

        /// <summary>Property added in version 2.0.0.0.</summary>
        public global::Microsoft.CodeAnalysis.DocumentId NewActiveContextDocumentId
        {
            get { return NewActiveContextDocumentIdGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 2.0.0.0.</summary>
        public global::Microsoft.CodeAnalysis.DocumentId OldActiveContextDocumentId
        {
            get { return OldActiveContextDocumentIdGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 2.0.0.0.</summary>
        public global::Microsoft.CodeAnalysis.Solution Solution
        {
            get { return SolutionGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 2.0.0.0.</summary>
        public global::Microsoft.CodeAnalysis.Text.SourceTextContainer SourceTextContainer
        {
            get { return SourceTextContainerGetterFunc(wrappedObject); }
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, an exception will be thrown.</summary>
        public static explicit operator DocumentActiveContextChangedEventArgsWrapper(global::System.EventArgs obj)
        {
            return Wrap(obj);
        }

        /// <summary>Returns the wrapped object.</summary>
        public static implicit operator global::System.EventArgs(DocumentActiveContextChangedEventArgsWrapper obj)
        {
            return obj.Unwrap();
        }

        /// <summary>Returns true if the specified object is compatible with this wrapper.</summary>
        public static bool Is(global::System.EventArgs? obj)
        {
            return global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.Is(obj, WrappedType);
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, an exception will be thrown.</summary>
        public static DocumentActiveContextChangedEventArgsWrapper Wrap(global::System.EventArgs obj)
        {
            var obj2 = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.Wrap<global::System.EventArgs>(obj, WrappedType);
            return new DocumentActiveContextChangedEventArgsWrapper(obj2);
        }

        /// <summary>Returns the wrapped object.</summary>
        public global::System.EventArgs Unwrap()
        {
            return wrappedObject;
        }
    }
}
";

        var test = CreateTest(AssemblyKind.WorkspacesCommon, "0.0.0.0", ["Microsoft.CodeAnalysis.DocumentActiveContextChangedEventArgs"]);
        var generatedFilePath = GetGeneratedFilePath("DocumentActiveContextChangedEventArgsWrapper.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestListPatternSyntax_V3_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.CSharp.Syntax.Lightup
{
    /// <summary>Provides lightup support for class Microsoft.CodeAnalysis.CSharp.Syntax.ListPatternSyntax. Added in version 4.1.0.0.</summary>
    public partial struct ListPatternSyntaxWrapper
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.CSharp.Syntax.ListPatternSyntax"";

        private static readonly global::System.Type? WrappedType;

        private delegate global::Microsoft.CodeAnalysis.SyntaxToken CloseBracketTokenGetterDelegate(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj);
        private delegate global::Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? DesignationGetterDelegate(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj);
        private delegate global::Microsoft.CodeAnalysis.SyntaxToken OpenBracketTokenGetterDelegate(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj);
        private delegate global::Microsoft.CodeAnalysis.SeparatedSyntaxList<global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax> PatternsGetterDelegate(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj);

        private delegate void AcceptDelegate0(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj, global::Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor);
        private delegate global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper AddPatternsDelegate0(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj, params global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax[] items);
        private delegate global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper UpdateDelegate0(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj, global::Microsoft.CodeAnalysis.SyntaxToken openBracketToken, global::Microsoft.CodeAnalysis.SeparatedSyntaxList<global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax> patterns, global::Microsoft.CodeAnalysis.SyntaxToken closeBracketToken, global::Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? designation);
        private delegate global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithCloseBracketTokenDelegate0(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj, global::Microsoft.CodeAnalysis.SyntaxToken closeBracketToken);
        private delegate global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithDesignationDelegate0(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj, global::Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? designation);
        private delegate global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithOpenBracketTokenDelegate0(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj, global::Microsoft.CodeAnalysis.SyntaxToken openBracketToken);
        private delegate global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithPatternsDelegate0(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax _obj, global::Microsoft.CodeAnalysis.SeparatedSyntaxList<global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax> patterns);

        private static readonly CloseBracketTokenGetterDelegate CloseBracketTokenGetterFunc;
        private static readonly DesignationGetterDelegate DesignationGetterFunc;
        private static readonly OpenBracketTokenGetterDelegate OpenBracketTokenGetterFunc;
        private static readonly PatternsGetterDelegate PatternsGetterFunc;

        private static readonly AcceptDelegate0 AcceptFunc0;
        private static readonly AddPatternsDelegate0 AddPatternsFunc0;
        private static readonly UpdateDelegate0 UpdateFunc0;
        private static readonly WithCloseBracketTokenDelegate0 WithCloseBracketTokenFunc0;
        private static readonly WithDesignationDelegate0 WithDesignationFunc0;
        private static readonly WithOpenBracketTokenDelegate0 WithOpenBracketTokenFunc0;
        private static readonly WithPatternsDelegate0 WithPatternsFunc0;

        private readonly global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax wrappedObject;

        static ListPatternSyntaxWrapper()
        {
            WrappedType = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.FindType(WrappedTypeName);

            CloseBracketTokenGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<CloseBracketTokenGetterDelegate>(WrappedType, nameof(CloseBracketToken));
            DesignationGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<DesignationGetterDelegate>(WrappedType, nameof(Designation));
            OpenBracketTokenGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<OpenBracketTokenGetterDelegate>(WrappedType, nameof(OpenBracketToken));
            PatternsGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<PatternsGetterDelegate>(WrappedType, nameof(Patterns));

            AcceptFunc0 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<AcceptDelegate0>(WrappedType, ""Accept"", ""visitorCSharpSyntaxVisitor"");
            AddPatternsFunc0 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<AddPatternsDelegate0>(WrappedType, ""AddPatterns"", ""itemsPatternSyntax[]"");
            UpdateFunc0 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<UpdateDelegate0>(WrappedType, ""Update"", ""openBracketTokenSyntaxToken"", ""patternsSeparatedSyntaxList`1"", ""closeBracketTokenSyntaxToken"", ""designationVariableDesignationSyntax"");
            WithCloseBracketTokenFunc0 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<WithCloseBracketTokenDelegate0>(WrappedType, ""WithCloseBracketToken"", ""closeBracketTokenSyntaxToken"");
            WithDesignationFunc0 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<WithDesignationDelegate0>(WrappedType, ""WithDesignation"", ""designationVariableDesignationSyntax"");
            WithOpenBracketTokenFunc0 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<WithOpenBracketTokenDelegate0>(WrappedType, ""WithOpenBracketToken"", ""openBracketTokenSyntaxToken"");
            WithPatternsFunc0 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<WithPatternsDelegate0>(WrappedType, ""WithPatterns"", ""patternsSeparatedSyntaxList`1"");
        }

        private ListPatternSyntaxWrapper(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax obj)
        {
            wrappedObject = obj;
        }

        /// <summary>Property added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken
        {
            get { return CloseBracketTokenGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? Designation
        {
            get { return DesignationGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken
        {
            get { return OpenBracketTokenGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.SeparatedSyntaxList<global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax> Patterns
        {
            get { return PatternsGetterFunc(wrappedObject); }
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, an exception will be thrown.</summary>
        public static explicit operator ListPatternSyntaxWrapper(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax obj)
        {
            return Wrap(obj);
        }

        /// <summary>Returns the wrapped object.</summary>
        public static implicit operator global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax(ListPatternSyntaxWrapper obj)
        {
            return obj.Unwrap();
        }

        /// <summary>Returns true if the specified object is compatible with this wrapper.</summary>
        public static bool Is(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax? obj)
        {
            return global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.Is(obj, WrappedType);
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, an exception will be thrown.</summary>
        public static ListPatternSyntaxWrapper Wrap(global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax obj)
        {
            var obj2 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.Wrap<global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax>(obj, WrappedType);
            return new ListPatternSyntaxWrapper(obj2);
        }

        /// <summary>Returns the wrapped object.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax Unwrap()
        {
            return wrappedObject;
        }

        /// <summary>Method added in version 4.1.0.0.</summary>
        public void Accept(global::Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor)
        {
            AcceptFunc0(wrappedObject, visitor);
        }

        /// <summary>Method added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper AddPatterns(params global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax[] items)
        {
            return AddPatternsFunc0(wrappedObject, items);
        }

        /// <summary>Method added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper Update(global::Microsoft.CodeAnalysis.SyntaxToken openBracketToken, global::Microsoft.CodeAnalysis.SeparatedSyntaxList<global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax> patterns, global::Microsoft.CodeAnalysis.SyntaxToken closeBracketToken, global::Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? designation)
        {
            return UpdateFunc0(wrappedObject, openBracketToken, patterns, closeBracketToken, designation);
        }

        /// <summary>Method added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithCloseBracketToken(global::Microsoft.CodeAnalysis.SyntaxToken closeBracketToken)
        {
            return WithCloseBracketTokenFunc0(wrappedObject, closeBracketToken);
        }

        /// <summary>Method added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithDesignation(global::Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? designation)
        {
            return WithDesignationFunc0(wrappedObject, designation);
        }

        /// <summary>Method added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithOpenBracketToken(global::Microsoft.CodeAnalysis.SyntaxToken openBracketToken)
        {
            return WithOpenBracketTokenFunc0(wrappedObject, openBracketToken);
        }

        /// <summary>Method added in version 4.1.0.0.</summary>
        public global::Microsoft.CodeAnalysis.CSharp.Syntax.Lightup.ListPatternSyntaxWrapper WithPatterns(global::Microsoft.CodeAnalysis.SeparatedSyntaxList<global::Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax> patterns)
        {
            return WithPatternsFunc0(wrappedObject, patterns);
        }
    }
}
";

        var test = CreateTest(AssemblyKind.CSharp, "3.0.0.0", ["Microsoft.CodeAnalysis.CSharp.Syntax.ListPatternSyntax"]);
        var generatedFilePath = GetGeneratedFilePath("CSharp", "Syntax", "ListPatternSyntaxWrapper.g.cs");
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), generatedFilePath, SourceText.From(source, Encoding.UTF8)));
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "SeparatedSyntaxListWrapper.g.cs", SourceText.From(SeparatedSyntaxListWrapperSource, Encoding.UTF8)));
        await test.RunAsync();
    }

    protected virtual string GetGeneratedFilePath(params string[] parts)
    {
        var result = $"Microsoft.CodeAnalysis.{string.Join(".", parts)}";
        return result;
    }

    private static CSharpSourceGeneratorTest<LightupGenerator, DefaultVerifier> CreateTest(
        AssemblyKind? assemblyKind,
        string? baselineVersion,
        List<string> typesToInclude,
        LanguageVersion? languageVersion = null,
        bool? useFoldersInFilePaths = null,
        bool shouldGeneratedFiles = true)
    {
        var na = (languageVersion == null || languageVersion >= LanguageVersion.CSharp8) ? "?" : "";
        useFoldersInFilePaths ??= Helpers.RoslynSupportsFoldersInGeneratedFilePaths;

        var lightupHelperSource = $@"
namespace CodeAnalysis.Lightup.Runtime
{{
    using System;
    using System.Reflection;
    
    public class LightupHelper
    {{
        public static Type{na} FindType(Assembly assembly, string wrappedTypeName)
            => throw new Exception();
        
        public static bool Is(object{na} obj, Type{na} wrappedType)
            => throw new Exception();
        
        public static TObject{na} Wrap<TObject>(object{na} obj, Type{na} wrappedType)
            where TObject : class
            => throw new Exception();        
        
        public static TDelegate CreateInstanceConstructorAccessor<TDelegate>(Type{na} wrappedType, params string[] paramTags)
            where TDelegate : Delegate
            => throw new Exception();
        
        public static TDelegate CreateInstanceGetAccessor<TDelegate>(Type{na} wrappedType, string memberName)
            where TDelegate : Delegate
            => throw new Exception();
        
        public static TDelegate CreateStaticMethodAccessor<TDelegate>(Type{na} wrappedType, string memberName, params string[] paramTags)
            where TDelegate : Delegate
            => throw new Exception();
        
        public static TDelegate CreateInstanceMethodAccessor<TDelegate>(Type{na} wrappedType, string memberName, params string[] paramTags)
            where TDelegate : Delegate
            => throw new Exception();
    }}
}}";

        var specificLightupHelperSource = $@"
// <auto-generated/>
{(languageVersion == null || languageVersion >= LanguageVersion.CSharp8 ? "#nullable enable" : "")}

namespace Microsoft.CodeAnalysis.Lightup
{{
    internal class {assemblyKind}LightupHelper : global::CodeAnalysis.Lightup.Runtime.LightupHelper
    {{
        private static readonly global::System.Reflection.Assembly Assembly = typeof(global::{ExampleTypeNames[assemblyKind ?? AssemblyKind.Common]}).Assembly;

        public static global::System.Type{na} FindType(string wrappedTypeName)
        {{
            return FindType(Assembly, wrappedTypeName);
        }}
    }}
}}
";

        var test = new CSharpSourceGeneratorTest<LightupGenerator, DefaultVerifier>()
        {
            TestState =
            {
                Sources = { lightupHelperSource },
            },
            ReferenceAssemblies = CreateReferenceAssemblies(),
        };

        if (shouldGeneratedFiles)
        {
            test.TestState.GeneratedSources.Add((typeof(LightupGenerator), $"{assemblyKind}LightupHelper.g.cs", SourceText.From(specificLightupHelperSource, Encoding.UTF8)));
        }

        test.SolutionTransforms.Add((solution, projectId) =>
        {
            if (languageVersion != null)
            {
                var project = solution.GetProject(projectId);
                var parseOptions = ((CSharpParseOptions)project!.ParseOptions!).WithLanguageVersion(languageVersion.Value);
                solution = solution.WithProjectParseOptions(projectId, parseOptions);
            }

            return solution;
        });

        var configFileContent = $@"{{
	{(assemblyKind != null ? $@"""assemblies"": [ ""{(assemblyKind != null ? AssemblyKindStrings[assemblyKind.Value] : "")}"" ]," : "")}
	{(baselineVersion != null ? $@"""baselineVersion"": ""{baselineVersion}""," : "")}
    ""includeTypes"": [ {string.Join(", ", typesToInclude.Select(x => $@"""{x}"""))} ],
    ""useFoldersInFilePaths"": {(useFoldersInFilePaths.Value ? "true" : "false")}
}}";
        test.TestState.AdditionalFiles.Add(("CodeAnalysis.Lightup.json", configFileContent));

        return test;
    }

    private static ReferenceAssemblies CreateReferenceAssemblies()
    {
        return ReferenceAssemblies.Net.Net90
            .AddPackages([new PackageIdentity("Microsoft.CodeAnalysis", "3.0.0")]);
    }
}
