
// <auto-generated/>
#pragma warning disable CS1591
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    public struct SeparatedSyntaxListWrapper<TNode>
        where TNode : struct
    {
        private static readonly global::System.Type? WrappedType;

        private delegate int CountDelegate(object obj);
        private delegate TNode IndexerDelegate(object obj, int index);
        private delegate global::Microsoft.CodeAnalysis.SyntaxToken GetSeparatorDelegate(object obj, int index);
        private delegate TNode FirstDelegate(object obj);
        private delegate TNode? FirstOrDefaultDelegate(object obj);
        private delegate TNode LastDelegate(object obj);
        private delegate TNode? LastOrDefaultDelegate(object obj);
        private delegate bool ContainsDelegate(object obj, TNode node);
        private delegate int IndexOfNodeDelegate(object obj, TNode node);
        private delegate int IndexOfPredicateDelegate(object obj, global::System.Func<TNode, bool> predicate);
        private delegate int LastIndexOfNodeDelegate(object obj, TNode node);
        private delegate int LastIndexOfPredicateDelegate(object obj, global::System.Func<TNode, bool> predicate);
        private delegate bool AnyDelegate(object obj);
        private delegate SeparatedSyntaxListWrapper<TNode> AddDelegate(object obj, TNode node);
        private delegate SeparatedSyntaxListWrapper<TNode> AddRangeDelegate(object obj, global::System.Collections.Generic.IEnumerable<TNode> arg1);
        private delegate SeparatedSyntaxListWrapper<TNode> InsertDelegate(object obj, int index, TNode node);
        private delegate SeparatedSyntaxListWrapper<TNode> InsertRangeDelegate(object obj, int index, global::System.Collections.Generic.IEnumerable<TNode> arg1);
        private delegate SeparatedSyntaxListWrapper<TNode> RemoveAtDelegate(object obj, int index);
        private delegate SeparatedSyntaxListWrapper<TNode> RemoveDelegate(object obj, TNode node);
        private delegate SeparatedSyntaxListWrapper<TNode> ReplaceDelegate(object obj, TNode nodeInList, TNode newNode);
        private delegate SeparatedSyntaxListWrapper<TNode> ReplaceRangeDelegate(object obj, TNode nodeInList, global::System.Collections.Generic.IEnumerable<TNode> newNodes);

        private static readonly CountDelegate CountAccessor;
        private static readonly IndexerDelegate IndexerAccessor;
        private static readonly GetSeparatorDelegate GetSeparatorAccessor;
        private static readonly FirstDelegate FirstAccessor;
        private static readonly FirstOrDefaultDelegate FirstOrDefaultAccessor;
        private static readonly LastDelegate LastAccessor;
        private static readonly LastOrDefaultDelegate LastOrDefaultAccessor;
        private static readonly ContainsDelegate ContainsAccessor;
        private static readonly IndexOfNodeDelegate IndexOfNodeAccessor;
        private static readonly IndexOfPredicateDelegate IndexOfPredicateAccessor;
        private static readonly LastIndexOfNodeDelegate LastIndexOfNodeAccessor;
        private static readonly LastIndexOfPredicateDelegate LastIndexOfPredicateAccessor;
        private static readonly AnyDelegate AnyAccessor;
        private static readonly AddDelegate AddAccessor;
        private static readonly AddRangeDelegate AddRangeAccessor;
        private static readonly InsertDelegate InsertAccessor;
        private static readonly InsertRangeDelegate InsertRangeAccessor;
        private static readonly RemoveAtDelegate RemoveAtAccessor;
        private static readonly RemoveDelegate RemoveAccessor;
        private static readonly ReplaceDelegate ReplaceAccessor;
        private static readonly ReplaceRangeDelegate ReplaceRangeAccessor;

        private readonly object wrappedObject;

        static SeparatedSyntaxListWrapper()
        {
            var wrapperNodeType = typeof(TNode);
            var wrappedNodeTypeField = wrapperNodeType.GetField("WrappedType", global::System.Reflection.BindingFlags.Static | global::System.Reflection.BindingFlags.NonPublic);
            var wrappedNodeType = (global::System.Type)wrappedNodeTypeField.GetValue(null);
            var wrappedNodeTypeName = wrappedNodeType?.Name;
            WrappedType = wrappedNodeType != null ? typeof(SeparatedSyntaxList<>).MakeGenericType(wrappedNodeType) : null;

            CountAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<CountDelegate>(WrappedType, nameof(Count));
            IndexerAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<IndexerDelegate>(WrappedType, "get_Item", "indexInt32");
            GetSeparatorAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<GetSeparatorDelegate>(WrappedType, nameof(GetSeparator), "indexInt32");
            FirstAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<FirstDelegate>(WrappedType, nameof(First));
            FirstOrDefaultAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<FirstOrDefaultDelegate>(WrappedType, nameof(FirstOrDefault));
            LastAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<LastDelegate>(WrappedType, nameof(Last));
            LastOrDefaultAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<LastOrDefaultDelegate>(WrappedType, nameof(LastOrDefault));
            ContainsAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<ContainsDelegate>(WrappedType, nameof(Contains), "node" + wrappedNodeTypeName);
            IndexOfNodeAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<IndexOfNodeDelegate>(WrappedType, nameof(IndexOf), "node" + wrappedNodeTypeName);
            IndexOfPredicateAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<IndexOfPredicateDelegate>(WrappedType, nameof(IndexOf), "predicateFunc`2");
            LastIndexOfNodeAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<LastIndexOfNodeDelegate>(WrappedType, nameof(LastIndexOf), "node" + wrappedNodeTypeName);
            LastIndexOfPredicateAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<LastIndexOfPredicateDelegate>(WrappedType, nameof(LastIndexOf), "predicateFunc`2");
            AnyAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<AnyDelegate>(WrappedType, nameof(Any));
            AddAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<AddDelegate>(WrappedType, nameof(Add), "node" + wrappedNodeTypeName);
            AddRangeAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<AddRangeDelegate>(WrappedType, nameof(AddRange), "nodesIEnumerable`1");
            InsertAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<InsertDelegate>(WrappedType, nameof(Insert), "indexInt32", "node" + wrappedNodeTypeName);
            InsertRangeAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<InsertRangeDelegate>(WrappedType, nameof(InsertRange), "indexInt32", "nodesIEnumerable`1");
            RemoveAtAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<RemoveAtDelegate>(WrappedType, nameof(RemoveAt), "indexInt32");
            RemoveAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<RemoveDelegate>(WrappedType, nameof(Remove), "node" + wrappedNodeTypeName);
            ReplaceAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<ReplaceDelegate>(WrappedType, nameof(Replace), "nodeInList" + wrappedNodeTypeName, "newNode" + wrappedNodeTypeName);
            ReplaceRangeAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<ReplaceRangeDelegate>(WrappedType, nameof(ReplaceRange), "nodeInList" + wrappedNodeTypeName, "newNodesIEnumerable`1");
        }

        private SeparatedSyntaxListWrapper(object obj)
        {
            wrappedObject = obj;
        }

        public int Count
        {
            get { return CountAccessor(wrappedObject); }
        }

        public int SeparatorCount
        {
            get { throw new global::System.NotImplementedException(); }
        }

        public global::Microsoft.CodeAnalysis.Text.TextSpan FullSpan
        {
             get { throw new global::System.NotImplementedException(); }
        }

        public global::Microsoft.CodeAnalysis.Text.TextSpan Span
        {
             get { throw new global::System.NotImplementedException(); }
        }

        public TNode this[int index]
        {
             get { return IndexerAccessor(wrappedObject, index); }
        }

        //public static implicit operator SeparatedSyntaxListWrapper<SyntaxNode>(SeparatedSyntaxListWrapper<TNode> nodes)
        //{
        //     throw new global::System.NotImplementedException();
        //}

        //public static implicit operator SeparatedSyntaxListWrapper<TNode>(SeparatedSyntaxListWrapper<SyntaxNode> nodes)
        //{
        //     throw new global::System.NotImplementedException();
        //}

        public static bool Is(object? obj)
        {
            return global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.Is(obj, WrappedType);
        }

        public static SeparatedSyntaxListWrapper<TNode> Wrap(object obj)
        {
            var obj2 = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.Wrap<object>(obj, WrappedType);
            return new SeparatedSyntaxListWrapper<TNode>(obj2);
        }

        public object Unwrap()
        {
             return wrappedObject;
        }

        public global::Microsoft.CodeAnalysis.SyntaxToken GetSeparator(int index)
        {
             return GetSeparatorAccessor(wrappedObject, index);
        }

        public global::System.Collections.Generic.IEnumerable<global::Microsoft.CodeAnalysis.SyntaxToken> GetSeparators()
        {
             throw new global::System.NotImplementedException();
        }

        public override string ToString()
        {
             throw new global::System.NotImplementedException();
        }

        public string ToFullString()
        {
             throw new global::System.NotImplementedException();
        }

        public TNode First()
        {
             return FirstAccessor(wrappedObject);
        }

        public TNode? FirstOrDefault()
        {
             return FirstOrDefaultAccessor(wrappedObject);
        }

        public TNode Last()
        {
             return LastAccessor(wrappedObject);
        }

        public TNode? LastOrDefault()
        {
             return LastOrDefaultAccessor(wrappedObject);
        }

        public bool Contains(TNode node)
        {
             return ContainsAccessor(wrappedObject, node);
        }

        public int IndexOf(TNode node)
        {
            return IndexOfNodeAccessor(wrappedObject, node);
        }

        public int IndexOf(global::System.Func<TNode, bool> predicate)
        {
            return IndexOfPredicateAccessor(wrappedObject, predicate);
        }

        public int LastIndexOf(TNode node)
        {
            return LastIndexOfNodeAccessor(wrappedObject, node);
        }

        public int LastIndexOf(global::System.Func<TNode, bool> predicate)
        {
            return LastIndexOfPredicateAccessor(wrappedObject, predicate);
        }

        public bool Any()
        {
            return AnyAccessor(wrappedObject);
        }

        public SyntaxNodeOrTokenList GetWithSeparators()
        {
             throw new global::System.NotImplementedException();
        }

        public SeparatedSyntaxListWrapper<TNode> Add(TNode node)
        {
             return AddAccessor(wrappedObject, node);
        }

        public SeparatedSyntaxListWrapper<TNode> AddRange(global::System.Collections.Generic.IEnumerable<TNode> nodes)
        {
             return AddRangeAccessor(wrappedObject, nodes);
        }

        public SeparatedSyntaxListWrapper<TNode> Insert(int index, TNode node)
        {
             return InsertAccessor(wrappedObject, index, node);
        }

        public SeparatedSyntaxListWrapper<TNode> InsertRange(int index, global::System.Collections.Generic.IEnumerable<TNode> nodes)
        {
             return InsertRangeAccessor(wrappedObject, index, nodes);
        }

        public SeparatedSyntaxListWrapper<TNode> RemoveAt(int index)
        {
             return RemoveAtAccessor(wrappedObject, index);
        }

        public SeparatedSyntaxListWrapper<TNode> Remove(TNode node)
        {
             return RemoveAccessor(wrappedObject, node);
        }

        public SeparatedSyntaxListWrapper<TNode> Replace(TNode nodeInList, TNode newNode)
        {
             return ReplaceAccessor(wrappedObject, nodeInList, newNode);
        }

        public SeparatedSyntaxListWrapper<TNode> ReplaceRange(TNode nodeInList, global::System.Collections.Generic.IEnumerable<TNode> newNodes)
        {
             return ReplaceRangeAccessor(wrappedObject, nodeInList, newNodes);
        }

        public SeparatedSyntaxListWrapper<TNode> ReplaceSeparator(global::Microsoft.CodeAnalysis.SyntaxToken separatorToken, global::Microsoft.CodeAnalysis.SyntaxToken newSeparator)
        {
             throw new global::System.NotImplementedException();
        }
    }
}
