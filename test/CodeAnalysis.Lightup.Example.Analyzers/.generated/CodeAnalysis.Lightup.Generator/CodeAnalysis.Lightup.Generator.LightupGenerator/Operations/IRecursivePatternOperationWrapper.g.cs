// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for interface Microsoft.CodeAnalysis.Operations.IRecursivePatternOperation. Added in version 3.3.0.0.</summary>
    public partial struct IRecursivePatternOperationWrapper
    {
        private const string WrappedTypeName = "Microsoft.CodeAnalysis.Operations.IRecursivePatternOperation";

        private static readonly global::System.Type? WrappedType; // NOTE: Used via reflection

        private delegate global::Microsoft.CodeAnalysis.ISymbol? DeclaredSymbolGetterDelegate(global::Microsoft.CodeAnalysis.Operations.IPatternOperation _obj);
        private delegate global::System.Collections.Immutable.ImmutableArray<global::Microsoft.CodeAnalysis.Operations.IPatternOperation> DeconstructionSubpatternsGetterDelegate(global::Microsoft.CodeAnalysis.Operations.IPatternOperation _obj);
        private delegate global::Microsoft.CodeAnalysis.ISymbol? DeconstructSymbolGetterDelegate(global::Microsoft.CodeAnalysis.Operations.IPatternOperation _obj);
        private delegate global::Microsoft.CodeAnalysis.ITypeSymbol MatchedTypeGetterDelegate(global::Microsoft.CodeAnalysis.Operations.IPatternOperation _obj);
        private delegate global::System.Collections.Immutable.ImmutableArray<global::Microsoft.CodeAnalysis.Operations.Lightup.IPropertySubpatternOperationWrapper> PropertySubpatternsGetterDelegate(global::Microsoft.CodeAnalysis.Operations.IPatternOperation _obj);

        private static readonly DeclaredSymbolGetterDelegate DeclaredSymbolGetterFunc;
        private static readonly DeconstructionSubpatternsGetterDelegate DeconstructionSubpatternsGetterFunc;
        private static readonly DeconstructSymbolGetterDelegate DeconstructSymbolGetterFunc;
        private static readonly MatchedTypeGetterDelegate MatchedTypeGetterFunc;
        private static readonly PropertySubpatternsGetterDelegate PropertySubpatternsGetterFunc;

        private readonly global::Microsoft.CodeAnalysis.Operations.IPatternOperation wrappedObject;

        static IRecursivePatternOperationWrapper()
        {
            WrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            DeclaredSymbolGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<DeclaredSymbolGetterDelegate>(WrappedType, nameof(DeclaredSymbol));
            DeconstructionSubpatternsGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<DeconstructionSubpatternsGetterDelegate>(WrappedType, nameof(DeconstructionSubpatterns));
            DeconstructSymbolGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<DeconstructSymbolGetterDelegate>(WrappedType, nameof(DeconstructSymbol));
            MatchedTypeGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<MatchedTypeGetterDelegate>(WrappedType, nameof(MatchedType));
            PropertySubpatternsGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<PropertySubpatternsGetterDelegate>(WrappedType, nameof(PropertySubpatterns));
        }

        private IRecursivePatternOperationWrapper(global::Microsoft.CodeAnalysis.Operations.IPatternOperation obj)
        {
            wrappedObject = obj;
        }

        /// <summary>Property added in version 3.3.0.0.</summary>
        public global::Microsoft.CodeAnalysis.ISymbol? DeclaredSymbol
        {
            get { return DeclaredSymbolGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 3.3.0.0.</summary>
        public global::System.Collections.Immutable.ImmutableArray<global::Microsoft.CodeAnalysis.Operations.IPatternOperation> DeconstructionSubpatterns
        {
            get { return DeconstructionSubpatternsGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 3.3.0.0.</summary>
        public global::Microsoft.CodeAnalysis.ISymbol? DeconstructSymbol
        {
            get { return DeconstructSymbolGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 3.3.0.0.</summary>
        public global::Microsoft.CodeAnalysis.ITypeSymbol MatchedType
        {
            get { return MatchedTypeGetterFunc(wrappedObject); }
        }

        /// <summary>Property added in version 3.3.0.0.</summary>
        public global::System.Collections.Immutable.ImmutableArray<global::Microsoft.CodeAnalysis.Operations.Lightup.IPropertySubpatternOperationWrapper> PropertySubpatterns
        {
            get { return PropertySubpatternsGetterFunc(wrappedObject); }
        }

        /// <summary>Returns true if the specified object is compatible with this wrapper.</summary>
        public static bool Is(global::Microsoft.CodeAnalysis.Operations.IPatternOperation? obj)
        {
            return global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.Is(obj, WrappedType);
        }

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, an exception will be thrown.</summary>
        public static IRecursivePatternOperationWrapper Wrap(global::Microsoft.CodeAnalysis.Operations.IPatternOperation obj)
        {
            var obj2 = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.Wrap<global::Microsoft.CodeAnalysis.Operations.IPatternOperation>(obj, WrappedType);
            return new IRecursivePatternOperationWrapper(obj2);
        }

        /// <summary>Returns the wrapped object.</summary>
        public global::Microsoft.CodeAnalysis.Operations.IPatternOperation Unwrap()
        {
            return wrappedObject;
        }
    }
}
