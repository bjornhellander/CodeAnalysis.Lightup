// Copyright © Björn Hellander 2024
// Licensed under the MIT License. See LICENSE.txt in the repository root for license information.

namespace CodeAnalysis.Lightup.Test.Generator;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CodeAnalysis.Lightup.Definitions;
using CodeAnalysis.Lightup.Generator;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Testing;
using Microsoft.CodeAnalysis.Testing;
using Microsoft.CodeAnalysis.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;

[TestClass]
public class LightupGeneratorTests
{
    private static readonly Dictionary<AssemblyKind, string> ExampleTypeNames = new()
    {
        [AssemblyKind.Common] = "Microsoft.CodeAnalysis.IOperation",
        [AssemblyKind.CSharp] = "Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax",
        [AssemblyKind.WorkspacesCommon] = "Microsoft.CodeAnalysis.WorkspaceChangeKind",
    };

    [TestMethod]
    public async Task TestSeparatedSyntaxListWrapper()
    {
        var source = @"
// <auto-generated/>
#pragma warning disable CS1591
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    // TODO: Implement remaining members
    public readonly struct SeparatedSyntaxListWrapper<TNode>
    {
        private static readonly global::System.Type? WrappedType; // NOTE: Possibly used via reflection

        private delegate int CountDelegate(object? obj);
        private delegate SeparatedSyntaxListWrapper<TNode> AddRangeDelegate(object? obj, global::System.Collections.Generic.IEnumerable<TNode> arg1);

        private static readonly CountDelegate CountAccessor;
        private static readonly AddRangeDelegate AddRangeAccessor;

        private readonly object? wrappedObject;

        static SeparatedSyntaxListWrapper()
        {
            var wrapperNodeType = typeof(TNode);
            var wrappedNodeTypeField = wrapperNodeType.GetField(""WrappedType"", global::System.Reflection.BindingFlags.Static | global::System.Reflection.BindingFlags.NonPublic);
            var wrappedNodeType = (global::System.Type)wrappedNodeTypeField.GetValue(null);
            WrappedType = wrappedNodeType != null ? typeof(SeparatedSyntaxList<>).MakeGenericType(wrappedNodeType) : null;

            CountAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceGetAccessor<CountDelegate>(WrappedType, nameof(Count));
            AddRangeAccessor = global::Microsoft.CodeAnalysis.Lightup.CSharpLightupHelper.CreateInstanceMethodAccessor<AddRangeDelegate>(WrappedType, nameof(AddRange), ""nodesIEnumerable`1"");
        }

        private SeparatedSyntaxListWrapper(object? obj)
        {
            wrappedObject = obj;
        }

        public readonly int Count
            => CountAccessor(wrappedObject);

        public readonly int SeparatorCount
            => throw new global::System.NotImplementedException();

        public readonly global::Microsoft.CodeAnalysis.Text.TextSpan FullSpan
            => throw new global::System.NotImplementedException();

        public readonly global::Microsoft.CodeAnalysis.Text.TextSpan Span
            => throw new global::System.NotImplementedException();

        public readonly TNode this[int index]
            => throw new global::System.NotImplementedException();

        public static implicit operator SeparatedSyntaxListWrapper<SyntaxNode>(SeparatedSyntaxListWrapper<TNode> nodes)
            => throw new global::System.NotImplementedException();

        public static implicit operator SeparatedSyntaxListWrapper<TNode>(SeparatedSyntaxListWrapper<SyntaxNode> nodes)
            => throw new global::System.NotImplementedException();

        public static bool Is(object? obj)
        {
            if (obj != null && obj.GetType() != WrappedType)
            {
                obj = null;
            }

            return obj != null;
        }

        public static SeparatedSyntaxListWrapper<TNode> As(object? obj)
        {
            if (obj != null && obj.GetType() != WrappedType)
            {
                obj = null;
            }

            return new SeparatedSyntaxListWrapper<TNode>(obj);
        }

        public readonly object? Unwrap()
            => wrappedObject;

        public readonly global::Microsoft.CodeAnalysis.SyntaxToken GetSeparator(int index)
            => throw new global::System.NotImplementedException();

        public readonly global::System.Collections.Generic.IEnumerable<global::Microsoft.CodeAnalysis.SyntaxToken> GetSeparators()
            => throw new global::System.NotImplementedException();

        public readonly override string ToString()
            => throw new global::System.NotImplementedException();

        public readonly string ToFullString()
            => throw new global::System.NotImplementedException();

        public readonly TNode First()
            => throw new global::System.NotImplementedException();

        public readonly TNode FirstOrDefault()
            => throw new global::System.NotImplementedException();

        public readonly TNode Last()
            => throw new global::System.NotImplementedException();

        public TNode LastOrDefault()
            => throw new global::System.NotImplementedException();

        public readonly bool Contains(TNode node)
            => throw new global::System.NotImplementedException();

        public readonly int IndexOf(TNode node)
            => throw new global::System.NotImplementedException();

        public readonly int IndexOf(global::System.Func<TNode, bool> predicate)
            => throw new global::System.NotImplementedException();

        public readonly int LastIndexOf(TNode node)
            => throw new global::System.NotImplementedException();

        public readonly int LastIndexOf(global::System.Func<TNode, bool> predicate)
            => throw new global::System.NotImplementedException();

        public readonly bool Any()
            => throw new global::System.NotImplementedException();

        public readonly SyntaxNodeOrTokenList GetWithSeparators()
            => throw new global::System.NotImplementedException();

        public readonly SeparatedSyntaxListWrapper<TNode> Add(TNode node)
            => throw new global::System.NotImplementedException();

        public readonly SeparatedSyntaxListWrapper<TNode> AddRange(global::System.Collections.Generic.IEnumerable<TNode> nodes)
            => AddRangeAccessor(wrappedObject, nodes);

        public readonly SeparatedSyntaxListWrapper<TNode> Insert(int index, TNode node)
            => throw new global::System.NotImplementedException();

        public readonly SeparatedSyntaxListWrapper<TNode> InsertRange(int index, global::System.Collections.Generic.IEnumerable<TNode> nodes)
            => throw new global::System.NotImplementedException();

        public readonly SeparatedSyntaxListWrapper<TNode> RemoveAt(int index)
            => throw new global::System.NotImplementedException();

        public readonly SeparatedSyntaxListWrapper<TNode> Remove(TNode node)
            => throw new global::System.NotImplementedException();

        public readonly SeparatedSyntaxListWrapper<TNode> Replace(TNode nodeInList, TNode newNode)
            => throw new global::System.NotImplementedException();

        public readonly SeparatedSyntaxListWrapper<TNode> ReplaceRange(TNode nodeInList, global::System.Collections.Generic.IEnumerable<TNode> newNodes)
            => throw new global::System.NotImplementedException();

        public readonly SeparatedSyntaxListWrapper<TNode> ReplaceSeparator(global::Microsoft.CodeAnalysis.SyntaxToken separatorToken, global::Microsoft.CodeAnalysis.SyntaxToken newSeparator)
            => throw new global::System.NotImplementedException();
    }
}
";

        var test = CreateTest(AssemblyKind.CSharp, "3.0.0.0", [""]);
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "SeparatedSyntaxListWrapper.g.cs", SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestCommonConversion_V3_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for struct Microsoft.CodeAnalysis.Operations.CommonConversion.</summary>
    public static partial class CommonConversionExtensions
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.Operations.CommonConversion"";

        private delegate global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToTypeGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion? _obj);
        private delegate global::System.Boolean IsNullableGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion? _obj);

        private static readonly ConstrainedToTypeGetterDelegate ConstrainedToTypeGetterFunc;
        private static readonly IsNullableGetterDelegate IsNullableGetterFunc;

        static CommonConversionExtensions()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            ConstrainedToTypeGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<ConstrainedToTypeGetterDelegate>(wrappedType, nameof(ConstrainedToType));
            IsNullableGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<IsNullableGetterDelegate>(wrappedType, nameof(IsNullable));
        }

        /// <summary>Property added in version 4.4.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToType(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
            => ConstrainedToTypeGetterFunc(_obj);

        /// <summary>Property added in version 3.8.0.0.</summary>
        public static global::System.Boolean IsNullable(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
            => IsNullableGetterFunc(_obj);
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.3.0.0", ["Microsoft.CodeAnalysis.Operations.CommonConversion"]);
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "Operations/CommonConversionExtensions.cs", SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestCommonConversion_V3_8_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for struct Microsoft.CodeAnalysis.Operations.CommonConversion.</summary>
    public static partial class CommonConversionExtensions
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.Operations.CommonConversion"";

        private delegate global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToTypeGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion? _obj);

        private static readonly ConstrainedToTypeGetterDelegate ConstrainedToTypeGetterFunc;

        static CommonConversionExtensions()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            ConstrainedToTypeGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<ConstrainedToTypeGetterDelegate>(wrappedType, nameof(ConstrainedToType));
        }

        /// <summary>Property added in version 4.4.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToType(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
            => ConstrainedToTypeGetterFunc(_obj);
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.8.0.0", ["Microsoft.CodeAnalysis.Operations.CommonConversion"]);
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "Operations/CommonConversionExtensions.cs", SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestCommonConversion_V3_8_0_0_CSharp7_3()
    {
        var source = @"// <auto-generated/>


namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for struct Microsoft.CodeAnalysis.Operations.CommonConversion.</summary>
    public static partial class CommonConversionExtensions
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.Operations.CommonConversion"";

        private delegate global::Microsoft.CodeAnalysis.ITypeSymbol ConstrainedToTypeGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj);

        private static readonly ConstrainedToTypeGetterDelegate ConstrainedToTypeGetterFunc;

        static CommonConversionExtensions()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            ConstrainedToTypeGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<ConstrainedToTypeGetterDelegate>(wrappedType, nameof(ConstrainedToType));
        }

        /// <summary>Property added in version 4.4.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ITypeSymbol ConstrainedToType(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
            => ConstrainedToTypeGetterFunc(_obj);
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.8.0.0", ["Microsoft.CodeAnalysis.Operations.CommonConversion"], LanguageVersion.CSharp7_3);
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "Operations/CommonConversionExtensions.cs", SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestBinaryOperatorKind_V3_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for enum Microsoft.CodeAnalysis.Operations.BinaryOperatorKind.</summary>
    public static partial class BinaryOperatorKindEx
    {
        /// <summary>Added in version 4.4.0.0.</summary>
        public const global::Microsoft.CodeAnalysis.Operations.BinaryOperatorKind UnsignedRightShift = (global::Microsoft.CodeAnalysis.Operations.BinaryOperatorKind)25;
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.0.0.0", ["Microsoft.CodeAnalysis.Operations.BinaryOperatorKind"]);
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "Operations/BinaryOperatorKindEx.cs", SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestBinaryOperatorKind_V4_4_0_0()
    {
        var test = CreateTest(AssemblyKind.Common, "4.4.0.0", ["Microsoft.CodeAnalysis.Operations.BinaryOperatorKind"]);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestGeneratedKind_V3_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for enum Microsoft.CodeAnalysis.GeneratedKind. Added in version 3.8.0.0.</summary>
    public enum GeneratedKindEx : global::System.Int32
    {
        /// <summary>Added in version 3.8.0.0.</summary>
        Unknown = 0,

        /// <summary>Added in version 3.8.0.0.</summary>
        NotGenerated = 1,

        /// <summary>Added in version 3.8.0.0.</summary>
        MarkedGenerated = 2,
    }
}
";

        var test = CreateTest(AssemblyKind.Common, "3.0.0.0", ["Microsoft.CodeAnalysis.GeneratedKind"]);
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "GeneratedKindEx.cs", SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestGeneratedKind_V3_8_0_0()
    {
        var test = CreateTest(AssemblyKind.Common, "3.8.0.0", ["Microsoft.CodeAnalysis.GeneratedKind"]);
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestSourceGeneratedDocument_V3_0_0_0()
    {
        var source = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    /// <summary>Provides lightup support for class Microsoft.CodeAnalysis.SourceGeneratedDocument. Added in version 4.0.0.0.</summary>
    public readonly partial struct SourceGeneratedDocumentWrapper
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.SourceGeneratedDocument"";

        private static readonly global::System.Type? WrappedType; // NOTE: Used via reflection

        private delegate global::System.String HintNameGetterDelegate(global::Microsoft.CodeAnalysis.Document? _obj);

        private static readonly HintNameGetterDelegate HintNameGetterFunc;

        private readonly global::Microsoft.CodeAnalysis.Document? wrappedObject;

        static SourceGeneratedDocumentWrapper()
        {
            WrappedType = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.FindType(WrappedTypeName);

            HintNameGetterFunc = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.CreateInstanceGetAccessor<HintNameGetterDelegate>(WrappedType, nameof(HintName));
        }

        private SourceGeneratedDocumentWrapper(global::Microsoft.CodeAnalysis.Document? obj)
        {
            wrappedObject = obj;
        }

        /// <summary>Property added in version 4.0.0.0.</summary>
        public readonly global::System.String HintName
        {
            get => HintNameGetterFunc(wrappedObject);
        }

        /// <summary>Returns the wrapped object.</summary>
        public static implicit operator global::Microsoft.CodeAnalysis.Document?(SourceGeneratedDocumentWrapper obj)
            => obj.Unwrap();

        /// <summary>Returns true if the specified object is compatible with this wrapper.</summary>
        public static bool Is(global::System.Object? obj)
            => global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.Is(obj, WrappedType);

        /// <summary>Creates a wrapper object containing the specified object. If the object is not compatible with this wrapper, null will be stored in the wrapper instead.</summary>
        public static SourceGeneratedDocumentWrapper As(global::System.Object? obj)
        {
            var obj2 = global::Microsoft.CodeAnalysis.Lightup.WorkspacesCommonLightupHelper.As<global::Microsoft.CodeAnalysis.Document>(obj, WrappedType);
            return new SourceGeneratedDocumentWrapper(obj2);
        }

        /// <summary>Returns the wrapped object.</summary>
        public global::Microsoft.CodeAnalysis.Document? Unwrap()
            => wrappedObject;
    }
}
";

        var test = CreateTest(AssemblyKind.WorkspacesCommon, "3.0.0.0", ["Microsoft.CodeAnalysis.SourceGeneratedDocument"]);
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "SourceGeneratedDocumentWrapper.cs", SourceText.From(source, Encoding.UTF8)));
        await test.RunAsync();
    }

    [TestMethod]
    public async Task TestSourceGeneratedDocument_V4_4_0_0()
    {
        var test = CreateTest(AssemblyKind.WorkspacesCommon, "4.4.0.0", ["Microsoft.CodeAnalysis.SourceGeneratedDocument"]);
        await test.RunAsync();
    }

    private static CSharpSourceGeneratorTest<LightupGenerator, DefaultVerifier> CreateTest(
        AssemblyKind assemblyKind,
        string baselineVersion,
        List<string> typesToInclude,
        LanguageVersion? languageVersion = null)
    {
        var na = (languageVersion == null || languageVersion >= LanguageVersion.CSharp8) ? "?" : "";

        var lightupHelperSource = $@"
namespace CodeAnalysis.Lightup.Runtime
{{
    using System;
    using System.Reflection;
    
    public class LightupHelper
    {{
        public static Type{na} FindType(Assembly assembly, string wrappedTypeName)
            => throw new Exception();
        
        public static bool Is(object{na} obj, Type{na} wrappedType)
            => throw new Exception();
        
        public static TObject{na} As<TObject>(object{na} obj, Type{na} wrappedType)
            where TObject : class
            => throw new Exception();        
        
        public static TDelegate CreateInstanceGetAccessor<TDelegate>(Type{na} wrappedType, string memberName)
            where TDelegate : Delegate
            => throw new Exception();

        public static TDelegate CreateInstanceMethodAccessor<TDelegate>(Type{na} wrappedType, string memberName, params string[] paramTags)
            where TDelegate : Delegate
            => throw new Exception();
    }}
}}";

        var specificLightupHelperSource = $@"
// <auto-generated/>
{(languageVersion == null || languageVersion >= LanguageVersion.CSharp8 ? "#nullable enable" : "")}

namespace Microsoft.CodeAnalysis.Lightup
{{
    internal class {assemblyKind}LightupHelper : global::CodeAnalysis.Lightup.Runtime.LightupHelper
    {{
        private static readonly global::System.Reflection.Assembly Assembly = typeof(global::{ExampleTypeNames[assemblyKind]}).Assembly;

        public static global::System.Type{na} FindType(string wrappedTypeName)
        {{
            return FindType(Assembly, wrappedTypeName);
        }}
    }}
}}
";

        var test = new CSharpSourceGeneratorTest<LightupGenerator, DefaultVerifier>()
        {
            TestState =
            {
                Sources = { lightupHelperSource },
                GeneratedSources =
                {
                    (typeof(LightupGenerator), $"{assemblyKind}LightupHelper.g.cs", SourceText.From(specificLightupHelperSource, Encoding.UTF8)),
                },
            },
            ReferenceAssemblies = CreateReferenceAssemblies(),
        };

        test.SolutionTransforms.Add((solution, projectId) =>
        {
            if (languageVersion != null)
            {
                var project = solution.GetProject(projectId);
                var parseOptions = ((CSharpParseOptions)project!.ParseOptions!).WithLanguageVersion(languageVersion.Value);
                solution = solution.WithProjectParseOptions(projectId, parseOptions);
            }

            return solution;
        });

        var configFileContent = $@"<?xml version=""1.0"" encoding=""utf-8""?>
<Settings>
	<Assembly>{assemblyKind}</Assembly>
	<BaselineVersion>{baselineVersion}</BaselineVersion>
    {string.Join(Environment.NewLine, typesToInclude.Select(x => $"<IncludeType>{x}</IncludeType>"))}
</Settings>
";
        test.TestState.AdditionalFiles.Add(("CodeAnalysis.Lightup.xml", configFileContent));

        return test;
    }

    private static ReferenceAssemblies CreateReferenceAssemblies()
    {
        return ReferenceAssemblies.Net.Net80
            .AddPackages([new PackageIdentity("Microsoft.CodeAnalysis", "3.0.0")]);
    }
}
