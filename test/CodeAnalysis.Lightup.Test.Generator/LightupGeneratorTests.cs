// Copyright © Björn Hellander 2024
// Licensed under the MIT License. See LICENSE.txt in the repository root for license information.

namespace CodeAnalysis.Lightup.Test.Generator;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CodeAnalysis.Lightup.Generator;
using Microsoft.CodeAnalysis.CSharp.Testing;
using Microsoft.CodeAnalysis.Testing;
using Microsoft.CodeAnalysis.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;

[TestClass]
public class LightupGeneratorTests
{
    [TestMethod]
    public async Task TestSingleType()
    {
        var commonConversionSource = @"// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Operations.Lightup
{
    /// <summary>Provides lightup support for struct Microsoft.CodeAnalysis.Operations.CommonConversion.</summary>
    public static partial class CommonConversionExtensions
    {
        private const string WrappedTypeName = ""Microsoft.CodeAnalysis.Operations.CommonConversion"";

        private delegate global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToTypeGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion? _obj);
        private delegate global::System.Boolean IsNullableGetterDelegate(global::Microsoft.CodeAnalysis.Operations.CommonConversion? _obj);

        private static readonly ConstrainedToTypeGetterDelegate ConstrainedToTypeGetterFunc;
        private static readonly IsNullableGetterDelegate IsNullableGetterFunc;

        static CommonConversionExtensions()
        {
            var wrappedType = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.FindType(WrappedTypeName);

            ConstrainedToTypeGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<ConstrainedToTypeGetterDelegate>(wrappedType, nameof(ConstrainedToType));
            IsNullableGetterFunc = global::Microsoft.CodeAnalysis.Lightup.CommonLightupHelper.CreateInstanceGetAccessor<IsNullableGetterDelegate>(wrappedType, nameof(IsNullable));
        }

        /// <summary>Property added in version 4.4.0.0.</summary>
        public static global::Microsoft.CodeAnalysis.ITypeSymbol? ConstrainedToType(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
            => ConstrainedToTypeGetterFunc(_obj);

        /// <summary>Property added in version 3.8.0.0.</summary>
        public static global::System.Boolean IsNullable(this global::Microsoft.CodeAnalysis.Operations.CommonConversion _obj)
            => IsNullableGetterFunc(_obj);
    }
}
";

        var test = CreateTest(["Microsoft.CodeAnalysis.Operations.CommonConversion"]);
        test.TestState.GeneratedSources.Add((typeof(LightupGenerator), "Operations/CommonConversionExtensions.cs", SourceText.From(commonConversionSource, Encoding.UTF8)));
        await test.RunAsync();
    }

    private static CSharpSourceGeneratorTest<LightupGenerator, DefaultVerifier> CreateTest(List<string> typesToInclude)
    {
        var lightupHelperSource = @"
namespace CodeAnalysis.Lightup.Runtime
{
    using System;
    using System.Reflection;
    
    public class LightupHelper
    {
        public static Type? FindType(Assembly assembly, string wrappedTypeName)
            => throw new Exception();
        
        public static TDelegate CreateInstanceGetAccessor<TDelegate>(Type? wrappedType, string memberName)
            where TDelegate : Delegate
            => throw new Exception();
    }
}
";

        var commonLightupHelperSource = @"
// <auto-generated/>
#nullable enable

namespace Microsoft.CodeAnalysis.Lightup
{
    internal class CommonLightupHelper : global::CodeAnalysis.Lightup.Runtime.LightupHelper
    {
        private static readonly global::System.Reflection.Assembly Assembly = typeof(global::Microsoft.CodeAnalysis.IOperation).Assembly;

        public static global::System.Type? FindType(string wrappedTypeName)
        {
            return FindType(Assembly, wrappedTypeName);
        }
    }
}
";

        var test = new CSharpSourceGeneratorTest<LightupGenerator, DefaultVerifier>()
        {
            TestState =
            {
                Sources = { lightupHelperSource },
                GeneratedSources =
                {
                    (typeof(LightupGenerator), "CommonLightupHelper.g.cs", SourceText.From(commonLightupHelperSource, Encoding.UTF8)),
                },
            },
            ReferenceAssemblies = CreateReferenceAssemblies(),
        };

        var configFileContent = $@"<?xml version=""1.0"" encoding=""utf-8""?>
<Settings>
	<Assembly>Common</Assembly>
	<BaselineVersion>3.0.0.0</BaselineVersion>
    {string.Join(Environment.NewLine, typesToInclude.Select(x => $"<IncludeType>{x}</IncludeType>"))}
</Settings>
";
        test.TestState.AdditionalFiles.Add(("CodeAnalysis.Lightup.xml", configFileContent));

        return test;
    }

    private static ReferenceAssemblies CreateReferenceAssemblies()
    {
        return ReferenceAssemblies.Net.Net80
            .AddPackages([new PackageIdentity("Microsoft.CodeAnalysis", "3.0.0")]);
    }
}
