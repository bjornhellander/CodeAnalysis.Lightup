// Copyright © Björn Hellander 2024
// Licensed under the MIT License. See LICENSE.txt in the repository root for license information.

// <auto-generated/>

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Reflection;
using System.Reflection.Metadata;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp.Syntax.Lightup;
using Microsoft.CodeAnalysis.Lightup;
using Microsoft.CodeAnalysis.Text;

namespace Microsoft.CodeAnalysis.CSharp.Lightup
{
    /// <summary>Provides lightup support for class Microsoft.CodeAnalysis.CSharp.CSharpExtensions.</summary>
    public static class CSharpExtensionsEx
    {
        private const string WrappedTypeName = "Microsoft.CodeAnalysis.CSharp.CSharpExtensions";

        private delegate DataFlowAnalysis? AnalyzeDataFlowDelegate0(SemanticModel? semanticModel, ConstructorInitializerSyntax constructorInitializer);
        private delegate DataFlowAnalysis? AnalyzeDataFlowDelegate1(SemanticModel? semanticModel, PrimaryConstructorBaseTypeSyntaxWrapper primaryConstructorBaseType);
        private delegate IMethodSymbol? GetDeclaredSymbolDelegate2(SemanticModel? semanticModel, CompilationUnitSyntax declarationSyntax, CancellationToken cancellationToken);
        private delegate INamespaceSymbol? GetDeclaredSymbolDelegate3(SemanticModel? semanticModel, FileScopedNamespaceDeclarationSyntaxWrapper declarationSyntax, CancellationToken cancellationToken);
        private delegate SymbolInfo GetSpeculativeSymbolInfoDelegate4(SemanticModel? semanticModel, Int32 position, PrimaryConstructorBaseTypeSyntaxWrapper constructorInitializer);
        private delegate SymbolInfo GetSymbolInfoDelegate5(SemanticModel? semanticModel, PrimaryConstructorBaseTypeSyntaxWrapper constructorInitializer, CancellationToken cancellationToken);
        private delegate Boolean TryGetSpeculativeSemanticModelDelegate6(SemanticModel? semanticModel, Int32 position, PrimaryConstructorBaseTypeSyntaxWrapper constructorInitializer, out SemanticModel? speculativeModel);

        private static readonly AnalyzeDataFlowDelegate0 AnalyzeDataFlowFunc0;
        private static readonly AnalyzeDataFlowDelegate1 AnalyzeDataFlowFunc1;
        private static readonly GetDeclaredSymbolDelegate2 GetDeclaredSymbolFunc2;
        private static readonly GetDeclaredSymbolDelegate3 GetDeclaredSymbolFunc3;
        private static readonly GetSpeculativeSymbolInfoDelegate4 GetSpeculativeSymbolInfoFunc4;
        private static readonly GetSymbolInfoDelegate5 GetSymbolInfoFunc5;
        private static readonly TryGetSpeculativeSemanticModelDelegate6 TryGetSpeculativeSemanticModelFunc6;

        static CSharpExtensionsEx()
        {
            var wrappedType = LightupHelper.FindType(WrappedTypeName);

            AnalyzeDataFlowFunc0 = LightupHelper.CreateStaticMethodAccessor<AnalyzeDataFlowDelegate0>(wrappedType, "AnalyzeDataFlow", "semanticModelSemanticModel", "constructorInitializerConstructorInitializerSyntax");
            AnalyzeDataFlowFunc1 = LightupHelper.CreateStaticMethodAccessor<AnalyzeDataFlowDelegate1>(wrappedType, "AnalyzeDataFlow", "semanticModelSemanticModel", "primaryConstructorBaseTypePrimaryConstructorBaseTypeSyntax");
            GetDeclaredSymbolFunc2 = LightupHelper.CreateStaticMethodAccessor<GetDeclaredSymbolDelegate2>(wrappedType, "GetDeclaredSymbol", "semanticModelSemanticModel", "declarationSyntaxCompilationUnitSyntax", "cancellationTokenCancellationToken");
            GetDeclaredSymbolFunc3 = LightupHelper.CreateStaticMethodAccessor<GetDeclaredSymbolDelegate3>(wrappedType, "GetDeclaredSymbol", "semanticModelSemanticModel", "declarationSyntaxFileScopedNamespaceDeclarationSyntax", "cancellationTokenCancellationToken");
            GetSpeculativeSymbolInfoFunc4 = LightupHelper.CreateStaticMethodAccessor<GetSpeculativeSymbolInfoDelegate4>(wrappedType, "GetSpeculativeSymbolInfo", "semanticModelSemanticModel", "positionInt32", "constructorInitializerPrimaryConstructorBaseTypeSyntax");
            GetSymbolInfoFunc5 = LightupHelper.CreateStaticMethodAccessor<GetSymbolInfoDelegate5>(wrappedType, "GetSymbolInfo", "semanticModelSemanticModel", "constructorInitializerPrimaryConstructorBaseTypeSyntax", "cancellationTokenCancellationToken");
            TryGetSpeculativeSemanticModelFunc6 = LightupHelper.CreateStaticMethodAccessor<TryGetSpeculativeSemanticModelDelegate6>(wrappedType, "TryGetSpeculativeSemanticModel", "semanticModelSemanticModel", "positionInt32", "constructorInitializerPrimaryConstructorBaseTypeSyntax", "speculativeModelSemanticModel&");
        }

        /// <summary>Method added in version 4.4.0.0.</summary>
        public static DataFlowAnalysis? AnalyzeDataFlow(this SemanticModel? semanticModel, ConstructorInitializerSyntax constructorInitializer)
            => AnalyzeDataFlowFunc0(semanticModel, constructorInitializer);

        /// <summary>Method added in version 4.4.0.0.</summary>
        public static DataFlowAnalysis? AnalyzeDataFlow(this SemanticModel? semanticModel, PrimaryConstructorBaseTypeSyntaxWrapper primaryConstructorBaseType)
            => AnalyzeDataFlowFunc1(semanticModel, primaryConstructorBaseType);

        /// <summary>Method added in version 3.8.0.0.</summary>
        public static IMethodSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, CompilationUnitSyntax declarationSyntax, CancellationToken cancellationToken)
            => GetDeclaredSymbolFunc2(semanticModel, declarationSyntax, cancellationToken);

        /// <summary>Method added in version 4.0.0.0.</summary>
        public static INamespaceSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, FileScopedNamespaceDeclarationSyntaxWrapper declarationSyntax, CancellationToken cancellationToken)
            => GetDeclaredSymbolFunc3(semanticModel, declarationSyntax, cancellationToken);

        /// <summary>Method added in version 3.8.0.0.</summary>
        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel? semanticModel, Int32 position, PrimaryConstructorBaseTypeSyntaxWrapper constructorInitializer)
            => GetSpeculativeSymbolInfoFunc4(semanticModel, position, constructorInitializer);

        /// <summary>Method added in version 3.8.0.0.</summary>
        public static SymbolInfo GetSymbolInfo(this SemanticModel? semanticModel, PrimaryConstructorBaseTypeSyntaxWrapper constructorInitializer, CancellationToken cancellationToken)
            => GetSymbolInfoFunc5(semanticModel, constructorInitializer, cancellationToken);

        /// <summary>Method added in version 3.8.0.0.</summary>
        public static Boolean TryGetSpeculativeSemanticModel(this SemanticModel? semanticModel, Int32 position, PrimaryConstructorBaseTypeSyntaxWrapper constructorInitializer, out SemanticModel? speculativeModel)
            => TryGetSpeculativeSemanticModelFunc6(semanticModel, position, constructorInitializer, out speculativeModel);
    }
}
