// <auto-generated/>

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Reflection;
using System.Reflection.Metadata;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp.Syntax.Lightup;
using Microsoft.CodeAnalysis.Lightup;
using Microsoft.CodeAnalysis.Text;

namespace Microsoft.CodeAnalysis.CSharp.Syntax.Lightup
{
    /// <summary>Class added in Roslyn version 4.0.0.0</summary>
    public readonly struct LineSpanDirectiveTriviaSyntaxWrapper
    {
        private const string WrappedTypeName = "Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax";

        public static readonly Type? WrappedType;

        private delegate SyntaxToken CharacterOffsetGetterDelegate(DirectiveTriviaSyntax? _obj);
        private delegate LineDirectivePositionSyntaxWrapper EndGetterDelegate(DirectiveTriviaSyntax? _obj);
        private delegate SyntaxToken EndOfDirectiveTokenGetterDelegate(DirectiveTriviaSyntax? _obj);
        private delegate SyntaxToken FileGetterDelegate(DirectiveTriviaSyntax? _obj);
        private delegate SyntaxToken HashTokenGetterDelegate(DirectiveTriviaSyntax? _obj);
        private delegate Boolean IsActiveGetterDelegate(DirectiveTriviaSyntax? _obj);
        private delegate SyntaxToken LineKeywordGetterDelegate(DirectiveTriviaSyntax? _obj);
        private delegate SyntaxToken MinusTokenGetterDelegate(DirectiveTriviaSyntax? _obj);
        private delegate LineDirectivePositionSyntaxWrapper StartGetterDelegate(DirectiveTriviaSyntax? _obj);

        private delegate void AcceptDelegate0(DirectiveTriviaSyntax? _obj, CSharpSyntaxVisitor visitor);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper UpdateDelegate1(DirectiveTriviaSyntax? _obj, SyntaxToken hashToken, SyntaxToken lineKeyword, LineDirectivePositionSyntaxWrapper start, SyntaxToken minusToken, LineDirectivePositionSyntaxWrapper end, SyntaxToken characterOffset, SyntaxToken file, SyntaxToken endOfDirectiveToken, Boolean isActive);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithCharacterOffsetDelegate2(DirectiveTriviaSyntax? _obj, SyntaxToken characterOffset);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithEndDelegate3(DirectiveTriviaSyntax? _obj, LineDirectivePositionSyntaxWrapper end);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithEndOfDirectiveTokenDelegate4(DirectiveTriviaSyntax? _obj, SyntaxToken endOfDirectiveToken);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithFileDelegate5(DirectiveTriviaSyntax? _obj, SyntaxToken file);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithHashTokenDelegate6(DirectiveTriviaSyntax? _obj, SyntaxToken hashToken);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithIsActiveDelegate7(DirectiveTriviaSyntax? _obj, Boolean isActive);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithLineKeywordDelegate8(DirectiveTriviaSyntax? _obj, SyntaxToken lineKeyword);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithMinusTokenDelegate9(DirectiveTriviaSyntax? _obj, SyntaxToken minusToken);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithStartDelegate10(DirectiveTriviaSyntax? _obj, LineDirectivePositionSyntaxWrapper start);

        private static readonly CharacterOffsetGetterDelegate CharacterOffsetGetterFunc;
        private static readonly EndGetterDelegate EndGetterFunc;
        private static readonly EndOfDirectiveTokenGetterDelegate EndOfDirectiveTokenGetterFunc;
        private static readonly FileGetterDelegate FileGetterFunc;
        private static readonly HashTokenGetterDelegate HashTokenGetterFunc;
        private static readonly IsActiveGetterDelegate IsActiveGetterFunc;
        private static readonly LineKeywordGetterDelegate LineKeywordGetterFunc;
        private static readonly MinusTokenGetterDelegate MinusTokenGetterFunc;
        private static readonly StartGetterDelegate StartGetterFunc;

        private static readonly AcceptDelegate0 AcceptFunc0;
        private static readonly UpdateDelegate1 UpdateFunc1;
        private static readonly WithCharacterOffsetDelegate2 WithCharacterOffsetFunc2;
        private static readonly WithEndDelegate3 WithEndFunc3;
        private static readonly WithEndOfDirectiveTokenDelegate4 WithEndOfDirectiveTokenFunc4;
        private static readonly WithFileDelegate5 WithFileFunc5;
        private static readonly WithHashTokenDelegate6 WithHashTokenFunc6;
        private static readonly WithIsActiveDelegate7 WithIsActiveFunc7;
        private static readonly WithLineKeywordDelegate8 WithLineKeywordFunc8;
        private static readonly WithMinusTokenDelegate9 WithMinusTokenFunc9;
        private static readonly WithStartDelegate10 WithStartFunc10;

        private readonly DirectiveTriviaSyntax? wrappedObject;

        static LineSpanDirectiveTriviaSyntaxWrapper()
        {
            WrappedType = LightupHelper.FindType(WrappedTypeName);

            CharacterOffsetGetterFunc = LightupHelper.CreateInstanceGetAccessor<CharacterOffsetGetterDelegate>(WrappedType, nameof(CharacterOffset));
            EndGetterFunc = LightupHelper.CreateInstanceGetAccessor<EndGetterDelegate>(WrappedType, nameof(End));
            EndOfDirectiveTokenGetterFunc = LightupHelper.CreateInstanceGetAccessor<EndOfDirectiveTokenGetterDelegate>(WrappedType, nameof(EndOfDirectiveToken));
            FileGetterFunc = LightupHelper.CreateInstanceGetAccessor<FileGetterDelegate>(WrappedType, nameof(File));
            HashTokenGetterFunc = LightupHelper.CreateInstanceGetAccessor<HashTokenGetterDelegate>(WrappedType, nameof(HashToken));
            IsActiveGetterFunc = LightupHelper.CreateInstanceGetAccessor<IsActiveGetterDelegate>(WrappedType, nameof(IsActive));
            LineKeywordGetterFunc = LightupHelper.CreateInstanceGetAccessor<LineKeywordGetterDelegate>(WrappedType, nameof(LineKeyword));
            MinusTokenGetterFunc = LightupHelper.CreateInstanceGetAccessor<MinusTokenGetterDelegate>(WrappedType, nameof(MinusToken));
            StartGetterFunc = LightupHelper.CreateInstanceGetAccessor<StartGetterDelegate>(WrappedType, nameof(Start));

            AcceptFunc0 = LightupHelper.CreateInstanceMethodAccessor<AcceptDelegate0>(WrappedType, nameof(Accept));
            UpdateFunc1 = LightupHelper.CreateInstanceMethodAccessor<UpdateDelegate1>(WrappedType, nameof(Update));
            WithCharacterOffsetFunc2 = LightupHelper.CreateInstanceMethodAccessor<WithCharacterOffsetDelegate2>(WrappedType, nameof(WithCharacterOffset));
            WithEndFunc3 = LightupHelper.CreateInstanceMethodAccessor<WithEndDelegate3>(WrappedType, nameof(WithEnd));
            WithEndOfDirectiveTokenFunc4 = LightupHelper.CreateInstanceMethodAccessor<WithEndOfDirectiveTokenDelegate4>(WrappedType, nameof(WithEndOfDirectiveToken));
            WithFileFunc5 = LightupHelper.CreateInstanceMethodAccessor<WithFileDelegate5>(WrappedType, nameof(WithFile));
            WithHashTokenFunc6 = LightupHelper.CreateInstanceMethodAccessor<WithHashTokenDelegate6>(WrappedType, nameof(WithHashToken));
            WithIsActiveFunc7 = LightupHelper.CreateInstanceMethodAccessor<WithIsActiveDelegate7>(WrappedType, nameof(WithIsActive));
            WithLineKeywordFunc8 = LightupHelper.CreateInstanceMethodAccessor<WithLineKeywordDelegate8>(WrappedType, nameof(WithLineKeyword));
            WithMinusTokenFunc9 = LightupHelper.CreateInstanceMethodAccessor<WithMinusTokenDelegate9>(WrappedType, nameof(WithMinusToken));
            WithStartFunc10 = LightupHelper.CreateInstanceMethodAccessor<WithStartDelegate10>(WrappedType, nameof(WithStart));
        }

        private LineSpanDirectiveTriviaSyntaxWrapper(DirectiveTriviaSyntax? obj)
        {
            wrappedObject = obj;
        }

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly SyntaxToken CharacterOffset
        {
            get => CharacterOffsetGetterFunc(wrappedObject);
        }

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly LineDirectivePositionSyntaxWrapper End
        {
            get => EndGetterFunc(wrappedObject);
        }

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly SyntaxToken EndOfDirectiveToken
        {
            get => EndOfDirectiveTokenGetterFunc(wrappedObject);
        }

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly SyntaxToken File
        {
            get => FileGetterFunc(wrappedObject);
        }

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly SyntaxToken HashToken
        {
            get => HashTokenGetterFunc(wrappedObject);
        }

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly Boolean IsActive
        {
            get => IsActiveGetterFunc(wrappedObject);
        }

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly SyntaxToken LineKeyword
        {
            get => LineKeywordGetterFunc(wrappedObject);
        }

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly SyntaxToken MinusToken
        {
            get => MinusTokenGetterFunc(wrappedObject);
        }

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly LineDirectivePositionSyntaxWrapper Start
        {
            get => StartGetterFunc(wrappedObject);
        }

        public static implicit operator DirectiveTriviaSyntax?(LineSpanDirectiveTriviaSyntaxWrapper obj)
            => obj.Unwrap();

        public static bool Is(object? obj)
            => LightupHelper.Is(obj, WrappedType);

        public static LineSpanDirectiveTriviaSyntaxWrapper As(object? obj)
        {
            var obj2 = LightupHelper.As<DirectiveTriviaSyntax>(obj, WrappedType);
            return new LineSpanDirectiveTriviaSyntaxWrapper(obj2);
        }

        public DirectiveTriviaSyntax? Unwrap()
            => wrappedObject;

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly void Accept(CSharpSyntaxVisitor visitor)
            => AcceptFunc0(wrappedObject, visitor);

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly LineSpanDirectiveTriviaSyntaxWrapper Update(SyntaxToken hashToken, SyntaxToken lineKeyword, LineDirectivePositionSyntaxWrapper start, SyntaxToken minusToken, LineDirectivePositionSyntaxWrapper end, SyntaxToken characterOffset, SyntaxToken file, SyntaxToken endOfDirectiveToken, Boolean isActive)
            => UpdateFunc1(wrappedObject, hashToken, lineKeyword, start, minusToken, end, characterOffset, file, endOfDirectiveToken, isActive);

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithCharacterOffset(SyntaxToken characterOffset)
            => WithCharacterOffsetFunc2(wrappedObject, characterOffset);

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithEnd(LineDirectivePositionSyntaxWrapper end)
            => WithEndFunc3(wrappedObject, end);

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
            => WithEndOfDirectiveTokenFunc4(wrappedObject, endOfDirectiveToken);

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithFile(SyntaxToken file)
            => WithFileFunc5(wrappedObject, file);

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithHashToken(SyntaxToken hashToken)
            => WithHashTokenFunc6(wrappedObject, hashToken);

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithIsActive(Boolean isActive)
            => WithIsActiveFunc7(wrappedObject, isActive);

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithLineKeyword(SyntaxToken lineKeyword)
            => WithLineKeywordFunc8(wrappedObject, lineKeyword);

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithMinusToken(SyntaxToken minusToken)
            => WithMinusTokenFunc9(wrappedObject, minusToken);

        /// <summary>Added in Roslyn version 4.0.0.0</summary>
        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithStart(LineDirectivePositionSyntaxWrapper start)
            => WithStartFunc10(wrappedObject, start);
    }
}
