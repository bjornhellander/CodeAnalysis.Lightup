// <auto-generated/>

#nullable enable

using Microsoft.CodeAnalysis.Lightup;
using System;

namespace Microsoft.CodeAnalysis.CSharp.Syntax.Lightup
{
    /// <summary>Class added in Roslyn version 4.0.0.0</summary>
    public readonly struct LineSpanDirectiveTriviaSyntaxWrapper
    {
        private const string WrappedTypeName = "Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax";

        public static readonly Type? WrappedType;

        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken> CharacterOffsetFunc;
        private static readonly Func<DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper> EndFunc;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken> EndOfDirectiveTokenFunc;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken> FileFunc;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken> HashTokenFunc;
        private static readonly Func<DirectiveTriviaSyntax?, Boolean> IsActiveFunc;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken> LineKeywordFunc;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken> MinusTokenFunc;
        private static readonly Func<DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper> StartFunc;

        private static readonly Action<DirectiveTriviaSyntax?, CSharpSyntaxVisitor> AcceptFunc0;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken, SyntaxToken, LineDirectivePositionSyntaxWrapper, SyntaxToken, LineDirectivePositionSyntaxWrapper, SyntaxToken, SyntaxToken, SyntaxToken, Boolean, LineSpanDirectiveTriviaSyntaxWrapper> UpdateFunc1;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper> WithCharacterOffsetFunc2;
        private static readonly Func<DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper, LineSpanDirectiveTriviaSyntaxWrapper> WithEndFunc3;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper> WithEndOfDirectiveTokenFunc4;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper> WithFileFunc5;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper> WithHashTokenFunc6;
        private static readonly Func<DirectiveTriviaSyntax?, Boolean, LineSpanDirectiveTriviaSyntaxWrapper> WithIsActiveFunc7;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper> WithLineKeywordFunc8;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper> WithMinusTokenFunc9;
        private static readonly Func<DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper, LineSpanDirectiveTriviaSyntaxWrapper> WithStartFunc10;

        private readonly DirectiveTriviaSyntax? wrappedObject;

        static LineSpanDirectiveTriviaSyntaxWrapper()
        {
            WrappedType = LightupHelper.FindType(WrappedTypeName);

            CharacterOffsetFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, SyntaxToken>(WrappedType, nameof(CharacterOffset));
            EndFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper>(WrappedType, nameof(End));
            EndOfDirectiveTokenFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, SyntaxToken>(WrappedType, nameof(EndOfDirectiveToken));
            FileFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, SyntaxToken>(WrappedType, nameof(File));
            HashTokenFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, SyntaxToken>(WrappedType, nameof(HashToken));
            IsActiveFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, Boolean>(WrappedType, nameof(IsActive));
            LineKeywordFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, SyntaxToken>(WrappedType, nameof(LineKeyword));
            MinusTokenFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, SyntaxToken>(WrappedType, nameof(MinusToken));
            StartFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper>(WrappedType, nameof(Start));

            AcceptFunc0 = LightupHelper.CreateVoidMethodAccessor<DirectiveTriviaSyntax?, CSharpSyntaxVisitor>(WrappedType, nameof(Accept));
            UpdateFunc1 = LightupHelper.CreateMethodAccessor<DirectiveTriviaSyntax?, SyntaxToken, SyntaxToken, LineDirectivePositionSyntaxWrapper, SyntaxToken, LineDirectivePositionSyntaxWrapper, SyntaxToken, SyntaxToken, SyntaxToken, Boolean, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(Update));
            WithCharacterOffsetFunc2 = LightupHelper.CreateMethodAccessor<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithCharacterOffset));
            WithEndFunc3 = LightupHelper.CreateMethodAccessor<DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithEnd));
            WithEndOfDirectiveTokenFunc4 = LightupHelper.CreateMethodAccessor<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithEndOfDirectiveToken));
            WithFileFunc5 = LightupHelper.CreateMethodAccessor<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithFile));
            WithHashTokenFunc6 = LightupHelper.CreateMethodAccessor<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithHashToken));
            WithIsActiveFunc7 = LightupHelper.CreateMethodAccessor<DirectiveTriviaSyntax?, Boolean, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithIsActive));
            WithLineKeywordFunc8 = LightupHelper.CreateMethodAccessor<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithLineKeyword));
            WithMinusTokenFunc9 = LightupHelper.CreateMethodAccessor<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithMinusToken));
            WithStartFunc10 = LightupHelper.CreateMethodAccessor<DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithStart));
        }

        private LineSpanDirectiveTriviaSyntaxWrapper(DirectiveTriviaSyntax? obj)
        {
            wrappedObject = obj;
        }

        public readonly SyntaxToken CharacterOffset
            => CharacterOffsetFunc(wrappedObject);

        public readonly LineDirectivePositionSyntaxWrapper End
            => EndFunc(wrappedObject);

        public readonly SyntaxToken EndOfDirectiveToken
            => EndOfDirectiveTokenFunc(wrappedObject);

        public readonly SyntaxToken File
            => FileFunc(wrappedObject);

        public readonly SyntaxToken HashToken
            => HashTokenFunc(wrappedObject);

        public readonly Boolean IsActive
            => IsActiveFunc(wrappedObject);

        public readonly SyntaxToken LineKeyword
            => LineKeywordFunc(wrappedObject);

        public readonly SyntaxToken MinusToken
            => MinusTokenFunc(wrappedObject);

        public readonly LineDirectivePositionSyntaxWrapper Start
            => StartFunc(wrappedObject);

        public static implicit operator DirectiveTriviaSyntax?(LineSpanDirectiveTriviaSyntaxWrapper obj)
            => obj.Unwrap();

        public static bool Is(object? obj)
            => LightupHelper.Is(obj, WrappedType);

        public static LineSpanDirectiveTriviaSyntaxWrapper As(object? obj)
        {
            var obj2 = LightupHelper.As<DirectiveTriviaSyntax>(obj, WrappedType);
            return new LineSpanDirectiveTriviaSyntaxWrapper(obj2);
        }

        public DirectiveTriviaSyntax? Unwrap()
            => wrappedObject;

        public readonly void Accept(CSharpSyntaxVisitor visitor)
            => AcceptFunc0(wrappedObject, visitor);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper Update(SyntaxToken hashToken, SyntaxToken lineKeyword, LineDirectivePositionSyntaxWrapper start, SyntaxToken minusToken, LineDirectivePositionSyntaxWrapper end, SyntaxToken characterOffset, SyntaxToken file, SyntaxToken endOfDirectiveToken, Boolean isActive)
            => UpdateFunc1(wrappedObject, hashToken, lineKeyword, start, minusToken, end, characterOffset, file, endOfDirectiveToken, isActive);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithCharacterOffset(SyntaxToken characterOffset)
            => WithCharacterOffsetFunc2(wrappedObject, characterOffset);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithEnd(LineDirectivePositionSyntaxWrapper end)
            => WithEndFunc3(wrappedObject, end);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
            => WithEndOfDirectiveTokenFunc4(wrappedObject, endOfDirectiveToken);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithFile(SyntaxToken file)
            => WithFileFunc5(wrappedObject, file);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithHashToken(SyntaxToken hashToken)
            => WithHashTokenFunc6(wrappedObject, hashToken);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithIsActive(Boolean isActive)
            => WithIsActiveFunc7(wrappedObject, isActive);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithLineKeyword(SyntaxToken lineKeyword)
            => WithLineKeywordFunc8(wrappedObject, lineKeyword);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithMinusToken(SyntaxToken minusToken)
            => WithMinusTokenFunc9(wrappedObject, minusToken);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithStart(LineDirectivePositionSyntaxWrapper start)
            => WithStartFunc10(wrappedObject, start);
    }
}
