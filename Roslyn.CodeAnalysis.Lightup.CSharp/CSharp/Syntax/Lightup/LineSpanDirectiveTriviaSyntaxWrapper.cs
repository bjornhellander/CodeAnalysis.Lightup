// <auto-generated/>

#nullable enable

using Microsoft.CodeAnalysis.Lightup;
using System;

namespace Microsoft.CodeAnalysis.CSharp.Syntax.Lightup
{
    public readonly struct LineSpanDirectiveTriviaSyntaxWrapper
    {
        private const string WrappedTypeName = "Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax";

        private static readonly Type? WrappedType;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken> CharacterOffsetFunc;
        private static readonly Func<DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper> EndFunc;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken> EndOfDirectiveTokenFunc;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken> FileFunc;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken> HashTokenFunc;
        private static readonly Func<DirectiveTriviaSyntax?, Boolean> IsActiveFunc;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken> LineKeywordFunc;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken> MinusTokenFunc;
        private static readonly Func<DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper> StartFunc;
        private static readonly Action<DirectiveTriviaSyntax?, CSharpSyntaxVisitor> AcceptFunc0;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken, SyntaxToken, LineDirectivePositionSyntaxWrapper, SyntaxToken, LineDirectivePositionSyntaxWrapper, SyntaxToken, SyntaxToken, SyntaxToken, Boolean, LineSpanDirectiveTriviaSyntaxWrapper> UpdateFunc1;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper> WithCharacterOffsetFunc2;
        private static readonly Func<DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper, LineSpanDirectiveTriviaSyntaxWrapper> WithEndFunc3;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper> WithEndOfDirectiveTokenFunc4;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper> WithFileFunc5;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper> WithHashTokenFunc6;
        private static readonly Func<DirectiveTriviaSyntax?, Boolean, LineSpanDirectiveTriviaSyntaxWrapper> WithIsActiveFunc7;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper> WithLineKeywordFunc8;
        private static readonly Func<DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper> WithMinusTokenFunc9;
        private static readonly Func<DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper, LineSpanDirectiveTriviaSyntaxWrapper> WithStartFunc10;

        private readonly DirectiveTriviaSyntax? WrappedObject;

        static LineSpanDirectiveTriviaSyntaxWrapper()
        {
            WrappedType = LightupHelper.FindSyntaxType(WrappedTypeName);
            CharacterOffsetFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, SyntaxToken>(WrappedType, nameof(CharacterOffset));
            EndFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper>(WrappedType, nameof(End));
            EndOfDirectiveTokenFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, SyntaxToken>(WrappedType, nameof(EndOfDirectiveToken));
            FileFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, SyntaxToken>(WrappedType, nameof(File));
            HashTokenFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, SyntaxToken>(WrappedType, nameof(HashToken));
            IsActiveFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, Boolean>(WrappedType, nameof(IsActive));
            LineKeywordFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, SyntaxToken>(WrappedType, nameof(LineKeyword));
            MinusTokenFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, SyntaxToken>(WrappedType, nameof(MinusToken));
            StartFunc = LightupHelper.CreateGetAccessor<DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper>(WrappedType, nameof(Start));
            AcceptFunc0 = LightupHelper.CreateVoidMethodAccessor<LineSpanDirectiveTriviaSyntaxWrapper, DirectiveTriviaSyntax?, CSharpSyntaxVisitor>(WrappedType, nameof(Accept));
            UpdateFunc1 = LightupHelper.CreateMethodAccessor<LineSpanDirectiveTriviaSyntaxWrapper, DirectiveTriviaSyntax?, SyntaxToken, SyntaxToken, LineDirectivePositionSyntaxWrapper, SyntaxToken, LineDirectivePositionSyntaxWrapper, SyntaxToken, SyntaxToken, SyntaxToken, Boolean, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(Update));
            WithCharacterOffsetFunc2 = LightupHelper.CreateMethodAccessor<LineSpanDirectiveTriviaSyntaxWrapper, DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithCharacterOffset));
            WithEndFunc3 = LightupHelper.CreateMethodAccessor<LineSpanDirectiveTriviaSyntaxWrapper, DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithEnd));
            WithEndOfDirectiveTokenFunc4 = LightupHelper.CreateMethodAccessor<LineSpanDirectiveTriviaSyntaxWrapper, DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithEndOfDirectiveToken));
            WithFileFunc5 = LightupHelper.CreateMethodAccessor<LineSpanDirectiveTriviaSyntaxWrapper, DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithFile));
            WithHashTokenFunc6 = LightupHelper.CreateMethodAccessor<LineSpanDirectiveTriviaSyntaxWrapper, DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithHashToken));
            WithIsActiveFunc7 = LightupHelper.CreateMethodAccessor<LineSpanDirectiveTriviaSyntaxWrapper, DirectiveTriviaSyntax?, Boolean, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithIsActive));
            WithLineKeywordFunc8 = LightupHelper.CreateMethodAccessor<LineSpanDirectiveTriviaSyntaxWrapper, DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithLineKeyword));
            WithMinusTokenFunc9 = LightupHelper.CreateMethodAccessor<LineSpanDirectiveTriviaSyntaxWrapper, DirectiveTriviaSyntax?, SyntaxToken, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithMinusToken));
            WithStartFunc10 = LightupHelper.CreateMethodAccessor<LineSpanDirectiveTriviaSyntaxWrapper, DirectiveTriviaSyntax?, LineDirectivePositionSyntaxWrapper, LineSpanDirectiveTriviaSyntaxWrapper>(WrappedType, nameof(WithStart));
        }

        private LineSpanDirectiveTriviaSyntaxWrapper(DirectiveTriviaSyntax? obj)
        {
            WrappedObject = obj;
        }

        public readonly SyntaxToken CharacterOffset
            => CharacterOffsetFunc(WrappedObject);

        public readonly LineDirectivePositionSyntaxWrapper End
            => EndFunc(WrappedObject);

        public readonly SyntaxToken EndOfDirectiveToken
            => EndOfDirectiveTokenFunc(WrappedObject);

        public readonly SyntaxToken File
            => FileFunc(WrappedObject);

        public readonly SyntaxToken HashToken
            => HashTokenFunc(WrappedObject);

        public readonly Boolean IsActive
            => IsActiveFunc(WrappedObject);

        public readonly SyntaxToken LineKeyword
            => LineKeywordFunc(WrappedObject);

        public readonly SyntaxToken MinusToken
            => MinusTokenFunc(WrappedObject);

        public readonly LineDirectivePositionSyntaxWrapper Start
            => StartFunc(WrappedObject);

        public static implicit operator DirectiveTriviaSyntax?(LineSpanDirectiveTriviaSyntaxWrapper obj)
            => obj.Unwrap();

        public static bool Is(object? obj)
            => LightupHelper.Is(obj, WrappedType);

        public static LineSpanDirectiveTriviaSyntaxWrapper As(object? obj)
        {
            var obj2 = LightupHelper.As<DirectiveTriviaSyntax>(obj, WrappedType);
            return new LineSpanDirectiveTriviaSyntaxWrapper(obj2);
        }

        public DirectiveTriviaSyntax? Unwrap()
            => WrappedObject;

        public readonly void Accept(CSharpSyntaxVisitor visitor)
            => AcceptFunc0(WrappedObject, visitor);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper Update(SyntaxToken hashToken, SyntaxToken lineKeyword, LineDirectivePositionSyntaxWrapper start, SyntaxToken minusToken, LineDirectivePositionSyntaxWrapper end, SyntaxToken characterOffset, SyntaxToken file, SyntaxToken endOfDirectiveToken, Boolean isActive)
            => UpdateFunc1(WrappedObject, hashToken, lineKeyword, start, minusToken, end, characterOffset, file, endOfDirectiveToken, isActive);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithCharacterOffset(SyntaxToken characterOffset)
            => WithCharacterOffsetFunc2(WrappedObject, characterOffset);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithEnd(LineDirectivePositionSyntaxWrapper end)
            => WithEndFunc3(WrappedObject, end);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
            => WithEndOfDirectiveTokenFunc4(WrappedObject, endOfDirectiveToken);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithFile(SyntaxToken file)
            => WithFileFunc5(WrappedObject, file);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithHashToken(SyntaxToken hashToken)
            => WithHashTokenFunc6(WrappedObject, hashToken);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithIsActive(Boolean isActive)
            => WithIsActiveFunc7(WrappedObject, isActive);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithLineKeyword(SyntaxToken lineKeyword)
            => WithLineKeywordFunc8(WrappedObject, lineKeyword);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithMinusToken(SyntaxToken minusToken)
            => WithMinusTokenFunc9(WrappedObject, minusToken);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithStart(LineDirectivePositionSyntaxWrapper start)
            => WithStartFunc10(WrappedObject, start);
    }
}
