// <auto-generated/>

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis.Lightup;

namespace Microsoft.CodeAnalysis.CSharp.Syntax.Lightup
{
    /// <summary>Class added in Roslyn version 4.0.0.0</summary>
    public readonly struct LineSpanDirectiveTriviaSyntaxWrapper
    {
        private const string WrappedTypeName = "Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax";

        public static readonly Type? WrappedType;

        private delegate SyntaxToken CharacterOffsetDelegate(DirectiveTriviaSyntax? _obj);
        private delegate LineDirectivePositionSyntaxWrapper EndDelegate(DirectiveTriviaSyntax? _obj);
        private delegate SyntaxToken EndOfDirectiveTokenDelegate(DirectiveTriviaSyntax? _obj);
        private delegate SyntaxToken FileDelegate(DirectiveTriviaSyntax? _obj);
        private delegate SyntaxToken HashTokenDelegate(DirectiveTriviaSyntax? _obj);
        private delegate Boolean IsActiveDelegate(DirectiveTriviaSyntax? _obj);
        private delegate SyntaxToken LineKeywordDelegate(DirectiveTriviaSyntax? _obj);
        private delegate SyntaxToken MinusTokenDelegate(DirectiveTriviaSyntax? _obj);
        private delegate LineDirectivePositionSyntaxWrapper StartDelegate(DirectiveTriviaSyntax? _obj);

        private delegate void AcceptDelegate0(DirectiveTriviaSyntax? _obj, CSharpSyntaxVisitor visitor);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper UpdateDelegate1(DirectiveTriviaSyntax? _obj, SyntaxToken hashToken, SyntaxToken lineKeyword, LineDirectivePositionSyntaxWrapper start, SyntaxToken minusToken, LineDirectivePositionSyntaxWrapper end, SyntaxToken characterOffset, SyntaxToken file, SyntaxToken endOfDirectiveToken, Boolean isActive);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithCharacterOffsetDelegate2(DirectiveTriviaSyntax? _obj, SyntaxToken characterOffset);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithEndDelegate3(DirectiveTriviaSyntax? _obj, LineDirectivePositionSyntaxWrapper end);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithEndOfDirectiveTokenDelegate4(DirectiveTriviaSyntax? _obj, SyntaxToken endOfDirectiveToken);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithFileDelegate5(DirectiveTriviaSyntax? _obj, SyntaxToken file);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithHashTokenDelegate6(DirectiveTriviaSyntax? _obj, SyntaxToken hashToken);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithIsActiveDelegate7(DirectiveTriviaSyntax? _obj, Boolean isActive);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithLineKeywordDelegate8(DirectiveTriviaSyntax? _obj, SyntaxToken lineKeyword);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithMinusTokenDelegate9(DirectiveTriviaSyntax? _obj, SyntaxToken minusToken);
        private delegate LineSpanDirectiveTriviaSyntaxWrapper WithStartDelegate10(DirectiveTriviaSyntax? _obj, LineDirectivePositionSyntaxWrapper start);

        private static readonly CharacterOffsetDelegate CharacterOffsetFunc;
        private static readonly EndDelegate EndFunc;
        private static readonly EndOfDirectiveTokenDelegate EndOfDirectiveTokenFunc;
        private static readonly FileDelegate FileFunc;
        private static readonly HashTokenDelegate HashTokenFunc;
        private static readonly IsActiveDelegate IsActiveFunc;
        private static readonly LineKeywordDelegate LineKeywordFunc;
        private static readonly MinusTokenDelegate MinusTokenFunc;
        private static readonly StartDelegate StartFunc;

        private static readonly AcceptDelegate0 AcceptFunc0;
        private static readonly UpdateDelegate1 UpdateFunc1;
        private static readonly WithCharacterOffsetDelegate2 WithCharacterOffsetFunc2;
        private static readonly WithEndDelegate3 WithEndFunc3;
        private static readonly WithEndOfDirectiveTokenDelegate4 WithEndOfDirectiveTokenFunc4;
        private static readonly WithFileDelegate5 WithFileFunc5;
        private static readonly WithHashTokenDelegate6 WithHashTokenFunc6;
        private static readonly WithIsActiveDelegate7 WithIsActiveFunc7;
        private static readonly WithLineKeywordDelegate8 WithLineKeywordFunc8;
        private static readonly WithMinusTokenDelegate9 WithMinusTokenFunc9;
        private static readonly WithStartDelegate10 WithStartFunc10;

        private readonly DirectiveTriviaSyntax? wrappedObject;

        static LineSpanDirectiveTriviaSyntaxWrapper()
        {
            WrappedType = LightupHelper.FindType(WrappedTypeName);

            CharacterOffsetFunc = LightupHelper.CreateGetAccessor<CharacterOffsetDelegate>(WrappedType, nameof(CharacterOffset));
            EndFunc = LightupHelper.CreateGetAccessor<EndDelegate>(WrappedType, nameof(End));
            EndOfDirectiveTokenFunc = LightupHelper.CreateGetAccessor<EndOfDirectiveTokenDelegate>(WrappedType, nameof(EndOfDirectiveToken));
            FileFunc = LightupHelper.CreateGetAccessor<FileDelegate>(WrappedType, nameof(File));
            HashTokenFunc = LightupHelper.CreateGetAccessor<HashTokenDelegate>(WrappedType, nameof(HashToken));
            IsActiveFunc = LightupHelper.CreateGetAccessor<IsActiveDelegate>(WrappedType, nameof(IsActive));
            LineKeywordFunc = LightupHelper.CreateGetAccessor<LineKeywordDelegate>(WrappedType, nameof(LineKeyword));
            MinusTokenFunc = LightupHelper.CreateGetAccessor<MinusTokenDelegate>(WrappedType, nameof(MinusToken));
            StartFunc = LightupHelper.CreateGetAccessor<StartDelegate>(WrappedType, nameof(Start));

            AcceptFunc0 = LightupHelper.CreateMethodAccessor<AcceptDelegate0>(WrappedType, nameof(Accept));
            UpdateFunc1 = LightupHelper.CreateMethodAccessor<UpdateDelegate1>(WrappedType, nameof(Update));
            WithCharacterOffsetFunc2 = LightupHelper.CreateMethodAccessor<WithCharacterOffsetDelegate2>(WrappedType, nameof(WithCharacterOffset));
            WithEndFunc3 = LightupHelper.CreateMethodAccessor<WithEndDelegate3>(WrappedType, nameof(WithEnd));
            WithEndOfDirectiveTokenFunc4 = LightupHelper.CreateMethodAccessor<WithEndOfDirectiveTokenDelegate4>(WrappedType, nameof(WithEndOfDirectiveToken));
            WithFileFunc5 = LightupHelper.CreateMethodAccessor<WithFileDelegate5>(WrappedType, nameof(WithFile));
            WithHashTokenFunc6 = LightupHelper.CreateMethodAccessor<WithHashTokenDelegate6>(WrappedType, nameof(WithHashToken));
            WithIsActiveFunc7 = LightupHelper.CreateMethodAccessor<WithIsActiveDelegate7>(WrappedType, nameof(WithIsActive));
            WithLineKeywordFunc8 = LightupHelper.CreateMethodAccessor<WithLineKeywordDelegate8>(WrappedType, nameof(WithLineKeyword));
            WithMinusTokenFunc9 = LightupHelper.CreateMethodAccessor<WithMinusTokenDelegate9>(WrappedType, nameof(WithMinusToken));
            WithStartFunc10 = LightupHelper.CreateMethodAccessor<WithStartDelegate10>(WrappedType, nameof(WithStart));
        }

        private LineSpanDirectiveTriviaSyntaxWrapper(DirectiveTriviaSyntax? obj)
        {
            wrappedObject = obj;
        }

        public readonly SyntaxToken CharacterOffset
            => CharacterOffsetFunc(wrappedObject);

        public readonly LineDirectivePositionSyntaxWrapper End
            => EndFunc(wrappedObject);

        public readonly SyntaxToken EndOfDirectiveToken
            => EndOfDirectiveTokenFunc(wrappedObject);

        public readonly SyntaxToken File
            => FileFunc(wrappedObject);

        public readonly SyntaxToken HashToken
            => HashTokenFunc(wrappedObject);

        public readonly Boolean IsActive
            => IsActiveFunc(wrappedObject);

        public readonly SyntaxToken LineKeyword
            => LineKeywordFunc(wrappedObject);

        public readonly SyntaxToken MinusToken
            => MinusTokenFunc(wrappedObject);

        public readonly LineDirectivePositionSyntaxWrapper Start
            => StartFunc(wrappedObject);

        public static implicit operator DirectiveTriviaSyntax?(LineSpanDirectiveTriviaSyntaxWrapper obj)
            => obj.Unwrap();

        public static bool Is(object? obj)
            => LightupHelper.Is(obj, WrappedType);

        public static LineSpanDirectiveTriviaSyntaxWrapper As(object? obj)
        {
            var obj2 = LightupHelper.As<DirectiveTriviaSyntax>(obj, WrappedType);
            return new LineSpanDirectiveTriviaSyntaxWrapper(obj2);
        }

        public DirectiveTriviaSyntax? Unwrap()
            => wrappedObject;

        public readonly void Accept(CSharpSyntaxVisitor visitor)
            => AcceptFunc0(wrappedObject, visitor);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper Update(SyntaxToken hashToken, SyntaxToken lineKeyword, LineDirectivePositionSyntaxWrapper start, SyntaxToken minusToken, LineDirectivePositionSyntaxWrapper end, SyntaxToken characterOffset, SyntaxToken file, SyntaxToken endOfDirectiveToken, Boolean isActive)
            => UpdateFunc1(wrappedObject, hashToken, lineKeyword, start, minusToken, end, characterOffset, file, endOfDirectiveToken, isActive);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithCharacterOffset(SyntaxToken characterOffset)
            => WithCharacterOffsetFunc2(wrappedObject, characterOffset);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithEnd(LineDirectivePositionSyntaxWrapper end)
            => WithEndFunc3(wrappedObject, end);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
            => WithEndOfDirectiveTokenFunc4(wrappedObject, endOfDirectiveToken);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithFile(SyntaxToken file)
            => WithFileFunc5(wrappedObject, file);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithHashToken(SyntaxToken hashToken)
            => WithHashTokenFunc6(wrappedObject, hashToken);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithIsActive(Boolean isActive)
            => WithIsActiveFunc7(wrappedObject, isActive);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithLineKeyword(SyntaxToken lineKeyword)
            => WithLineKeywordFunc8(wrappedObject, lineKeyword);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithMinusToken(SyntaxToken minusToken)
            => WithMinusTokenFunc9(wrappedObject, minusToken);

        public readonly LineSpanDirectiveTriviaSyntaxWrapper WithStart(LineDirectivePositionSyntaxWrapper start)
            => WithStartFunc10(wrappedObject, start);
    }
}
