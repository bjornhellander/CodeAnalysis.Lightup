// <auto-generated/>

#nullable enable

using Microsoft.CodeAnalysis.Lightup;
using System;

namespace Microsoft.CodeAnalysis.CSharp.Syntax.Lightup
{
    /// <summary>Added in Roslyn version 3.8.0.0</summary>
    public readonly struct FunctionPointerCallingConventionSyntaxWrapper
    {
        private const string WrappedTypeName = "Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax";

        public static readonly Type? WrappedType;

        private static readonly Func<CSharpSyntaxNode?, SyntaxToken> ManagedOrUnmanagedKeywordFunc;
        private static readonly Func<CSharpSyntaxNode?, FunctionPointerUnmanagedCallingConventionListSyntaxWrapper> UnmanagedCallingConventionListFunc;

        private static readonly Action<CSharpSyntaxNode?, CSharpSyntaxVisitor> AcceptFunc0;
        private static readonly Func<CSharpSyntaxNode?, FunctionPointerUnmanagedCallingConventionSyntaxWrapper[], FunctionPointerCallingConventionSyntaxWrapper> AddUnmanagedCallingConventionListCallingConventionsFunc1;
        private static readonly Func<CSharpSyntaxNode?, SyntaxToken, FunctionPointerUnmanagedCallingConventionListSyntaxWrapper, FunctionPointerCallingConventionSyntaxWrapper> UpdateFunc2;
        private static readonly Func<CSharpSyntaxNode?, SyntaxToken, FunctionPointerCallingConventionSyntaxWrapper> WithManagedOrUnmanagedKeywordFunc3;
        private static readonly Func<CSharpSyntaxNode?, FunctionPointerUnmanagedCallingConventionListSyntaxWrapper, FunctionPointerCallingConventionSyntaxWrapper> WithUnmanagedCallingConventionListFunc4;

        private readonly CSharpSyntaxNode? wrappedObject;

        static FunctionPointerCallingConventionSyntaxWrapper()
        {
            WrappedType = CSharpLightupHelper.FindSyntaxType(WrappedTypeName);

            ManagedOrUnmanagedKeywordFunc = CommonLightupHelper.CreateGetAccessor<CSharpSyntaxNode?, SyntaxToken>(WrappedType, nameof(ManagedOrUnmanagedKeyword));
            UnmanagedCallingConventionListFunc = CommonLightupHelper.CreateGetAccessor<CSharpSyntaxNode?, FunctionPointerUnmanagedCallingConventionListSyntaxWrapper>(WrappedType, nameof(UnmanagedCallingConventionList));

            AcceptFunc0 = CommonLightupHelper.CreateVoidMethodAccessor<CSharpSyntaxNode?, CSharpSyntaxVisitor>(WrappedType, nameof(Accept));
            AddUnmanagedCallingConventionListCallingConventionsFunc1 = CommonLightupHelper.CreateMethodAccessor<CSharpSyntaxNode?, FunctionPointerUnmanagedCallingConventionSyntaxWrapper[], FunctionPointerCallingConventionSyntaxWrapper>(WrappedType, nameof(AddUnmanagedCallingConventionListCallingConventions));
            UpdateFunc2 = CommonLightupHelper.CreateMethodAccessor<CSharpSyntaxNode?, SyntaxToken, FunctionPointerUnmanagedCallingConventionListSyntaxWrapper, FunctionPointerCallingConventionSyntaxWrapper>(WrappedType, nameof(Update));
            WithManagedOrUnmanagedKeywordFunc3 = CommonLightupHelper.CreateMethodAccessor<CSharpSyntaxNode?, SyntaxToken, FunctionPointerCallingConventionSyntaxWrapper>(WrappedType, nameof(WithManagedOrUnmanagedKeyword));
            WithUnmanagedCallingConventionListFunc4 = CommonLightupHelper.CreateMethodAccessor<CSharpSyntaxNode?, FunctionPointerUnmanagedCallingConventionListSyntaxWrapper, FunctionPointerCallingConventionSyntaxWrapper>(WrappedType, nameof(WithUnmanagedCallingConventionList));
        }

        private FunctionPointerCallingConventionSyntaxWrapper(CSharpSyntaxNode? obj)
        {
            wrappedObject = obj;
        }

        public readonly SyntaxToken ManagedOrUnmanagedKeyword
            => ManagedOrUnmanagedKeywordFunc(wrappedObject);

        public readonly FunctionPointerUnmanagedCallingConventionListSyntaxWrapper UnmanagedCallingConventionList
            => UnmanagedCallingConventionListFunc(wrappedObject);

        public static implicit operator CSharpSyntaxNode?(FunctionPointerCallingConventionSyntaxWrapper obj)
            => obj.Unwrap();

        public static bool Is(object? obj)
            => CommonLightupHelper.Is(obj, WrappedType);

        public static FunctionPointerCallingConventionSyntaxWrapper As(object? obj)
        {
            var obj2 = CommonLightupHelper.As<CSharpSyntaxNode>(obj, WrappedType);
            return new FunctionPointerCallingConventionSyntaxWrapper(obj2);
        }

        public CSharpSyntaxNode? Unwrap()
            => wrappedObject;

        public readonly void Accept(CSharpSyntaxVisitor visitor)
            => AcceptFunc0(wrappedObject, visitor);

        public readonly FunctionPointerCallingConventionSyntaxWrapper AddUnmanagedCallingConventionListCallingConventions(params FunctionPointerUnmanagedCallingConventionSyntaxWrapper[] items)
            => AddUnmanagedCallingConventionListCallingConventionsFunc1(wrappedObject, items);

        public readonly FunctionPointerCallingConventionSyntaxWrapper Update(SyntaxToken managedOrUnmanagedKeyword, FunctionPointerUnmanagedCallingConventionListSyntaxWrapper unmanagedCallingConventionList)
            => UpdateFunc2(wrappedObject, managedOrUnmanagedKeyword, unmanagedCallingConventionList);

        public readonly FunctionPointerCallingConventionSyntaxWrapper WithManagedOrUnmanagedKeyword(SyntaxToken managedOrUnmanagedKeyword)
            => WithManagedOrUnmanagedKeywordFunc3(wrappedObject, managedOrUnmanagedKeyword);

        public readonly FunctionPointerCallingConventionSyntaxWrapper WithUnmanagedCallingConventionList(FunctionPointerUnmanagedCallingConventionListSyntaxWrapper unmanagedCallingConventionList)
            => WithUnmanagedCallingConventionListFunc4(wrappedObject, unmanagedCallingConventionList);
    }
}
