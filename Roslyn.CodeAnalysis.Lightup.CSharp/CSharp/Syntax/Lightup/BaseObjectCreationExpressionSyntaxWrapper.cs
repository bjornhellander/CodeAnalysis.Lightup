// <auto-generated/>

#nullable enable

using Microsoft.CodeAnalysis.Lightup;
using System;

namespace Microsoft.CodeAnalysis.CSharp.Syntax.Lightup
{
    public readonly struct BaseObjectCreationExpressionSyntaxWrapper
    {
        private const string WrappedTypeName = "Microsoft.CodeAnalysis.CSharp.Syntax.BaseObjectCreationExpressionSyntax";

        private static readonly Type? WrappedType;
        private static readonly Func<ExpressionSyntax?, ArgumentListSyntax?> ArgumentListFunc;
        private static readonly Func<ExpressionSyntax?, InitializerExpressionSyntax?> InitializerFunc;
        private static readonly Func<ExpressionSyntax?, SyntaxToken> NewKeywordFunc;
        private static readonly Func<ExpressionSyntax?, ArgumentSyntax[], BaseObjectCreationExpressionSyntaxWrapper> AddArgumentListArgumentsFunc0;
        private static readonly Func<ExpressionSyntax?, ArgumentListSyntax?, BaseObjectCreationExpressionSyntaxWrapper> WithArgumentListFunc1;
        private static readonly Func<ExpressionSyntax?, InitializerExpressionSyntax?, BaseObjectCreationExpressionSyntaxWrapper> WithInitializerFunc2;
        private static readonly Func<ExpressionSyntax?, SyntaxToken, BaseObjectCreationExpressionSyntaxWrapper> WithNewKeywordFunc3;

        private readonly ExpressionSyntax? wrappedObject;

        static BaseObjectCreationExpressionSyntaxWrapper()
        {
            WrappedType = LightupHelper.FindSyntaxType(WrappedTypeName);
            ArgumentListFunc = LightupHelper.CreateGetAccessor<ExpressionSyntax?, ArgumentListSyntax?>(WrappedType, nameof(ArgumentList));
            InitializerFunc = LightupHelper.CreateGetAccessor<ExpressionSyntax?, InitializerExpressionSyntax?>(WrappedType, nameof(Initializer));
            NewKeywordFunc = LightupHelper.CreateGetAccessor<ExpressionSyntax?, SyntaxToken>(WrappedType, nameof(NewKeyword));
            AddArgumentListArgumentsFunc0 = LightupHelper.CreateMethodAccessor<BaseObjectCreationExpressionSyntaxWrapper, ExpressionSyntax?, ArgumentSyntax[], BaseObjectCreationExpressionSyntaxWrapper>(WrappedType, nameof(AddArgumentListArguments));
            WithArgumentListFunc1 = LightupHelper.CreateMethodAccessor<BaseObjectCreationExpressionSyntaxWrapper, ExpressionSyntax?, ArgumentListSyntax?, BaseObjectCreationExpressionSyntaxWrapper>(WrappedType, nameof(WithArgumentList));
            WithInitializerFunc2 = LightupHelper.CreateMethodAccessor<BaseObjectCreationExpressionSyntaxWrapper, ExpressionSyntax?, InitializerExpressionSyntax?, BaseObjectCreationExpressionSyntaxWrapper>(WrappedType, nameof(WithInitializer));
            WithNewKeywordFunc3 = LightupHelper.CreateMethodAccessor<BaseObjectCreationExpressionSyntaxWrapper, ExpressionSyntax?, SyntaxToken, BaseObjectCreationExpressionSyntaxWrapper>(WrappedType, nameof(WithNewKeyword));
        }

        private BaseObjectCreationExpressionSyntaxWrapper(ExpressionSyntax? obj)
        {
            wrappedObject = obj;
        }

        public readonly ArgumentListSyntax? ArgumentList
            => ArgumentListFunc(wrappedObject);

        public readonly InitializerExpressionSyntax? Initializer
            => InitializerFunc(wrappedObject);

        public readonly SyntaxToken NewKeyword
            => NewKeywordFunc(wrappedObject);

        public static implicit operator ExpressionSyntax?(BaseObjectCreationExpressionSyntaxWrapper obj)
            => obj.Unwrap();

        public static bool Is(object? obj)
            => LightupHelper.Is(obj, WrappedType);

        public static BaseObjectCreationExpressionSyntaxWrapper As(object? obj)
        {
            var obj2 = LightupHelper.As<ExpressionSyntax>(obj, WrappedType);
            return new BaseObjectCreationExpressionSyntaxWrapper(obj2);
        }

        public ExpressionSyntax? Unwrap()
            => wrappedObject;

        public readonly BaseObjectCreationExpressionSyntaxWrapper AddArgumentListArguments(ArgumentSyntax[] items)
            => AddArgumentListArgumentsFunc0(wrappedObject, items);

        public readonly BaseObjectCreationExpressionSyntaxWrapper WithArgumentList(ArgumentListSyntax? argumentList)
            => WithArgumentListFunc1(wrappedObject, argumentList);

        public readonly BaseObjectCreationExpressionSyntaxWrapper WithInitializer(InitializerExpressionSyntax? initializer)
            => WithInitializerFunc2(wrappedObject, initializer);

        public readonly BaseObjectCreationExpressionSyntaxWrapper WithNewKeyword(SyntaxToken newKeyword)
            => WithNewKeywordFunc3(wrappedObject, newKeyword);
    }
}
